// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#![allow(dead_code, non_camel_case_types, non_upper_case_globals)]
/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 32;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_UIO_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _SYS_SYSLOG_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_SYSLOG_PATH_H: u32 = 1;
pub const _PATH_LOG: &'static [u8; 9usize] = b"/dev/log\0";
pub const LOG_EMERG: u32 = 0;
pub const LOG_ALERT: u32 = 1;
pub const LOG_CRIT: u32 = 2;
pub const LOG_ERR: u32 = 3;
pub const LOG_WARNING: u32 = 4;
pub const LOG_NOTICE: u32 = 5;
pub const LOG_INFO: u32 = 6;
pub const LOG_DEBUG: u32 = 7;
pub const LOG_PRIMASK: u32 = 7;
pub const LOG_KERN: u32 = 0;
pub const LOG_USER: u32 = 8;
pub const LOG_MAIL: u32 = 16;
pub const LOG_DAEMON: u32 = 24;
pub const LOG_AUTH: u32 = 32;
pub const LOG_SYSLOG: u32 = 40;
pub const LOG_LPR: u32 = 48;
pub const LOG_NEWS: u32 = 56;
pub const LOG_UUCP: u32 = 64;
pub const LOG_CRON: u32 = 72;
pub const LOG_AUTHPRIV: u32 = 80;
pub const LOG_FTP: u32 = 88;
pub const LOG_LOCAL0: u32 = 128;
pub const LOG_LOCAL1: u32 = 136;
pub const LOG_LOCAL2: u32 = 144;
pub const LOG_LOCAL3: u32 = 152;
pub const LOG_LOCAL4: u32 = 160;
pub const LOG_LOCAL5: u32 = 168;
pub const LOG_LOCAL6: u32 = 176;
pub const LOG_LOCAL7: u32 = 184;
pub const LOG_NFACILITIES: u32 = 24;
pub const LOG_FACMASK: u32 = 1016;
pub const LOG_PID: u32 = 1;
pub const LOG_CONS: u32 = 2;
pub const LOG_ODELAY: u32 = 4;
pub const LOG_NDELAY: u32 = 8;
pub const LOG_NOWAIT: u32 = 16;
pub const LOG_PERROR: u32 = 32;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const PCI_CFG_SPACE_SIZE: u32 = 256;
pub const PCI_CFG_SPACE_EXP_SIZE: u32 = 4096;
pub const PCI_STD_HEADER_SIZEOF: u32 = 64;
pub const PCI_STD_NUM_BARS: u32 = 6;
pub const PCI_VENDOR_ID: u32 = 0;
pub const PCI_DEVICE_ID: u32 = 2;
pub const PCI_COMMAND: u32 = 4;
pub const PCI_COMMAND_IO: u32 = 1;
pub const PCI_COMMAND_MEMORY: u32 = 2;
pub const PCI_COMMAND_MASTER: u32 = 4;
pub const PCI_COMMAND_SPECIAL: u32 = 8;
pub const PCI_COMMAND_INVALIDATE: u32 = 16;
pub const PCI_COMMAND_VGA_PALETTE: u32 = 32;
pub const PCI_COMMAND_PARITY: u32 = 64;
pub const PCI_COMMAND_WAIT: u32 = 128;
pub const PCI_COMMAND_SERR: u32 = 256;
pub const PCI_COMMAND_FAST_BACK: u32 = 512;
pub const PCI_COMMAND_INTX_DISABLE: u32 = 1024;
pub const PCI_STATUS: u32 = 6;
pub const PCI_STATUS_IMM_READY: u32 = 1;
pub const PCI_STATUS_INTERRUPT: u32 = 8;
pub const PCI_STATUS_CAP_LIST: u32 = 16;
pub const PCI_STATUS_66MHZ: u32 = 32;
pub const PCI_STATUS_UDF: u32 = 64;
pub const PCI_STATUS_FAST_BACK: u32 = 128;
pub const PCI_STATUS_PARITY: u32 = 256;
pub const PCI_STATUS_DEVSEL_MASK: u32 = 1536;
pub const PCI_STATUS_DEVSEL_FAST: u32 = 0;
pub const PCI_STATUS_DEVSEL_MEDIUM: u32 = 512;
pub const PCI_STATUS_DEVSEL_SLOW: u32 = 1024;
pub const PCI_STATUS_SIG_TARGET_ABORT: u32 = 2048;
pub const PCI_STATUS_REC_TARGET_ABORT: u32 = 4096;
pub const PCI_STATUS_REC_MASTER_ABORT: u32 = 8192;
pub const PCI_STATUS_SIG_SYSTEM_ERROR: u32 = 16384;
pub const PCI_STATUS_DETECTED_PARITY: u32 = 32768;
pub const PCI_CLASS_REVISION: u32 = 8;
pub const PCI_REVISION_ID: u32 = 8;
pub const PCI_CLASS_PROG: u32 = 9;
pub const PCI_CLASS_DEVICE: u32 = 10;
pub const PCI_CACHE_LINE_SIZE: u32 = 12;
pub const PCI_LATENCY_TIMER: u32 = 13;
pub const PCI_HEADER_TYPE: u32 = 14;
pub const PCI_HEADER_TYPE_MASK: u32 = 127;
pub const PCI_HEADER_TYPE_NORMAL: u32 = 0;
pub const PCI_HEADER_TYPE_BRIDGE: u32 = 1;
pub const PCI_HEADER_TYPE_CARDBUS: u32 = 2;
pub const PCI_BIST: u32 = 15;
pub const PCI_BIST_CODE_MASK: u32 = 15;
pub const PCI_BIST_START: u32 = 64;
pub const PCI_BIST_CAPABLE: u32 = 128;
pub const PCI_BASE_ADDRESS_0: u32 = 16;
pub const PCI_BASE_ADDRESS_1: u32 = 20;
pub const PCI_BASE_ADDRESS_2: u32 = 24;
pub const PCI_BASE_ADDRESS_3: u32 = 28;
pub const PCI_BASE_ADDRESS_4: u32 = 32;
pub const PCI_BASE_ADDRESS_5: u32 = 36;
pub const PCI_BASE_ADDRESS_SPACE: u32 = 1;
pub const PCI_BASE_ADDRESS_SPACE_IO: u32 = 1;
pub const PCI_BASE_ADDRESS_SPACE_MEMORY: u32 = 0;
pub const PCI_BASE_ADDRESS_MEM_TYPE_MASK: u32 = 6;
pub const PCI_BASE_ADDRESS_MEM_TYPE_32: u32 = 0;
pub const PCI_BASE_ADDRESS_MEM_TYPE_1M: u32 = 2;
pub const PCI_BASE_ADDRESS_MEM_TYPE_64: u32 = 4;
pub const PCI_BASE_ADDRESS_MEM_PREFETCH: u32 = 8;
pub const PCI_BASE_ADDRESS_MEM_MASK: i32 = -16;
pub const PCI_BASE_ADDRESS_IO_MASK: i32 = -4;
pub const PCI_CARDBUS_CIS: u32 = 40;
pub const PCI_SUBSYSTEM_VENDOR_ID: u32 = 44;
pub const PCI_SUBSYSTEM_ID: u32 = 46;
pub const PCI_ROM_ADDRESS: u32 = 48;
pub const PCI_ROM_ADDRESS_ENABLE: u32 = 1;
pub const PCI_ROM_ADDRESS_MASK: i32 = -2048;
pub const PCI_CAPABILITY_LIST: u32 = 52;
pub const PCI_INTERRUPT_LINE: u32 = 60;
pub const PCI_INTERRUPT_PIN: u32 = 61;
pub const PCI_MIN_GNT: u32 = 62;
pub const PCI_MAX_LAT: u32 = 63;
pub const PCI_PRIMARY_BUS: u32 = 24;
pub const PCI_SECONDARY_BUS: u32 = 25;
pub const PCI_SUBORDINATE_BUS: u32 = 26;
pub const PCI_SEC_LATENCY_TIMER: u32 = 27;
pub const PCI_IO_BASE: u32 = 28;
pub const PCI_IO_LIMIT: u32 = 29;
pub const PCI_IO_RANGE_TYPE_MASK: u32 = 15;
pub const PCI_IO_RANGE_TYPE_16: u32 = 0;
pub const PCI_IO_RANGE_TYPE_32: u32 = 1;
pub const PCI_IO_RANGE_MASK: i32 = -16;
pub const PCI_IO_1K_RANGE_MASK: i32 = -4;
pub const PCI_SEC_STATUS: u32 = 30;
pub const PCI_MEMORY_BASE: u32 = 32;
pub const PCI_MEMORY_LIMIT: u32 = 34;
pub const PCI_MEMORY_RANGE_TYPE_MASK: u32 = 15;
pub const PCI_MEMORY_RANGE_MASK: i32 = -16;
pub const PCI_PREF_MEMORY_BASE: u32 = 36;
pub const PCI_PREF_MEMORY_LIMIT: u32 = 38;
pub const PCI_PREF_RANGE_TYPE_MASK: u32 = 15;
pub const PCI_PREF_RANGE_TYPE_32: u32 = 0;
pub const PCI_PREF_RANGE_TYPE_64: u32 = 1;
pub const PCI_PREF_RANGE_MASK: i32 = -16;
pub const PCI_PREF_BASE_UPPER32: u32 = 40;
pub const PCI_PREF_LIMIT_UPPER32: u32 = 44;
pub const PCI_IO_BASE_UPPER16: u32 = 48;
pub const PCI_IO_LIMIT_UPPER16: u32 = 50;
pub const PCI_ROM_ADDRESS1: u32 = 56;
pub const PCI_BRIDGE_CONTROL: u32 = 62;
pub const PCI_BRIDGE_CTL_PARITY: u32 = 1;
pub const PCI_BRIDGE_CTL_SERR: u32 = 2;
pub const PCI_BRIDGE_CTL_ISA: u32 = 4;
pub const PCI_BRIDGE_CTL_VGA: u32 = 8;
pub const PCI_BRIDGE_CTL_MASTER_ABORT: u32 = 32;
pub const PCI_BRIDGE_CTL_BUS_RESET: u32 = 64;
pub const PCI_BRIDGE_CTL_FAST_BACK: u32 = 128;
pub const PCI_CB_CAPABILITY_LIST: u32 = 20;
pub const PCI_CB_SEC_STATUS: u32 = 22;
pub const PCI_CB_PRIMARY_BUS: u32 = 24;
pub const PCI_CB_CARD_BUS: u32 = 25;
pub const PCI_CB_SUBORDINATE_BUS: u32 = 26;
pub const PCI_CB_LATENCY_TIMER: u32 = 27;
pub const PCI_CB_MEMORY_BASE_0: u32 = 28;
pub const PCI_CB_MEMORY_LIMIT_0: u32 = 32;
pub const PCI_CB_MEMORY_BASE_1: u32 = 36;
pub const PCI_CB_MEMORY_LIMIT_1: u32 = 40;
pub const PCI_CB_IO_BASE_0: u32 = 44;
pub const PCI_CB_IO_BASE_0_HI: u32 = 46;
pub const PCI_CB_IO_LIMIT_0: u32 = 48;
pub const PCI_CB_IO_LIMIT_0_HI: u32 = 50;
pub const PCI_CB_IO_BASE_1: u32 = 52;
pub const PCI_CB_IO_BASE_1_HI: u32 = 54;
pub const PCI_CB_IO_LIMIT_1: u32 = 56;
pub const PCI_CB_IO_LIMIT_1_HI: u32 = 58;
pub const PCI_CB_IO_RANGE_MASK: i32 = -4;
pub const PCI_CB_BRIDGE_CONTROL: u32 = 62;
pub const PCI_CB_BRIDGE_CTL_PARITY: u32 = 1;
pub const PCI_CB_BRIDGE_CTL_SERR: u32 = 2;
pub const PCI_CB_BRIDGE_CTL_ISA: u32 = 4;
pub const PCI_CB_BRIDGE_CTL_VGA: u32 = 8;
pub const PCI_CB_BRIDGE_CTL_MASTER_ABORT: u32 = 32;
pub const PCI_CB_BRIDGE_CTL_CB_RESET: u32 = 64;
pub const PCI_CB_BRIDGE_CTL_16BIT_INT: u32 = 128;
pub const PCI_CB_BRIDGE_CTL_PREFETCH_MEM0: u32 = 256;
pub const PCI_CB_BRIDGE_CTL_PREFETCH_MEM1: u32 = 512;
pub const PCI_CB_BRIDGE_CTL_POST_WRITES: u32 = 1024;
pub const PCI_CB_SUBSYSTEM_VENDOR_ID: u32 = 64;
pub const PCI_CB_SUBSYSTEM_ID: u32 = 66;
pub const PCI_CB_LEGACY_MODE_BASE: u32 = 68;
pub const PCI_CAP_LIST_ID: u32 = 0;
pub const PCI_CAP_ID_PM: u32 = 1;
pub const PCI_CAP_ID_AGP: u32 = 2;
pub const PCI_CAP_ID_VPD: u32 = 3;
pub const PCI_CAP_ID_SLOTID: u32 = 4;
pub const PCI_CAP_ID_MSI: u32 = 5;
pub const PCI_CAP_ID_CHSWP: u32 = 6;
pub const PCI_CAP_ID_PCIX: u32 = 7;
pub const PCI_CAP_ID_HT: u32 = 8;
pub const PCI_CAP_ID_VNDR: u32 = 9;
pub const PCI_CAP_ID_DBG: u32 = 10;
pub const PCI_CAP_ID_CCRC: u32 = 11;
pub const PCI_CAP_ID_SHPC: u32 = 12;
pub const PCI_CAP_ID_SSVID: u32 = 13;
pub const PCI_CAP_ID_AGP3: u32 = 14;
pub const PCI_CAP_ID_SECDEV: u32 = 15;
pub const PCI_CAP_ID_EXP: u32 = 16;
pub const PCI_CAP_ID_MSIX: u32 = 17;
pub const PCI_CAP_ID_SATA: u32 = 18;
pub const PCI_CAP_ID_AF: u32 = 19;
pub const PCI_CAP_ID_EA: u32 = 20;
pub const PCI_CAP_ID_MAX: u32 = 20;
pub const PCI_CAP_LIST_NEXT: u32 = 1;
pub const PCI_CAP_FLAGS: u32 = 2;
pub const PCI_CAP_SIZEOF: u32 = 4;
pub const PCI_PM_PMC: u32 = 2;
pub const PCI_PM_CAP_VER_MASK: u32 = 7;
pub const PCI_PM_CAP_PME_CLOCK: u32 = 8;
pub const PCI_PM_CAP_RESERVED: u32 = 16;
pub const PCI_PM_CAP_DSI: u32 = 32;
pub const PCI_PM_CAP_AUX_POWER: u32 = 448;
pub const PCI_PM_CAP_D1: u32 = 512;
pub const PCI_PM_CAP_D2: u32 = 1024;
pub const PCI_PM_CAP_PME: u32 = 2048;
pub const PCI_PM_CAP_PME_MASK: u32 = 63488;
pub const PCI_PM_CAP_PME_D0: u32 = 2048;
pub const PCI_PM_CAP_PME_D1: u32 = 4096;
pub const PCI_PM_CAP_PME_D2: u32 = 8192;
pub const PCI_PM_CAP_PME_D3hot: u32 = 16384;
pub const PCI_PM_CAP_PME_D3cold: u32 = 32768;
pub const PCI_PM_CAP_PME_SHIFT: u32 = 11;
pub const PCI_PM_CTRL: u32 = 4;
pub const PCI_PM_CTRL_STATE_MASK: u32 = 3;
pub const PCI_PM_CTRL_NO_SOFT_RESET: u32 = 8;
pub const PCI_PM_CTRL_PME_ENABLE: u32 = 256;
pub const PCI_PM_CTRL_DATA_SEL_MASK: u32 = 7680;
pub const PCI_PM_CTRL_DATA_SCALE_MASK: u32 = 24576;
pub const PCI_PM_CTRL_PME_STATUS: u32 = 32768;
pub const PCI_PM_PPB_EXTENSIONS: u32 = 6;
pub const PCI_PM_PPB_B2_B3: u32 = 64;
pub const PCI_PM_BPCC_ENABLE: u32 = 128;
pub const PCI_PM_DATA_REGISTER: u32 = 7;
pub const PCI_PM_SIZEOF: u32 = 8;
pub const PCI_AGP_VERSION: u32 = 2;
pub const PCI_AGP_RFU: u32 = 3;
pub const PCI_AGP_STATUS: u32 = 4;
pub const PCI_AGP_STATUS_RQ_MASK: u32 = 4278190080;
pub const PCI_AGP_STATUS_SBA: u32 = 512;
pub const PCI_AGP_STATUS_64BIT: u32 = 32;
pub const PCI_AGP_STATUS_FW: u32 = 16;
pub const PCI_AGP_STATUS_RATE4: u32 = 4;
pub const PCI_AGP_STATUS_RATE2: u32 = 2;
pub const PCI_AGP_STATUS_RATE1: u32 = 1;
pub const PCI_AGP_COMMAND: u32 = 8;
pub const PCI_AGP_COMMAND_RQ_MASK: u32 = 4278190080;
pub const PCI_AGP_COMMAND_SBA: u32 = 512;
pub const PCI_AGP_COMMAND_AGP: u32 = 256;
pub const PCI_AGP_COMMAND_64BIT: u32 = 32;
pub const PCI_AGP_COMMAND_FW: u32 = 16;
pub const PCI_AGP_COMMAND_RATE4: u32 = 4;
pub const PCI_AGP_COMMAND_RATE2: u32 = 2;
pub const PCI_AGP_COMMAND_RATE1: u32 = 1;
pub const PCI_AGP_SIZEOF: u32 = 12;
pub const PCI_VPD_ADDR: u32 = 2;
pub const PCI_VPD_ADDR_MASK: u32 = 32767;
pub const PCI_VPD_ADDR_F: u32 = 32768;
pub const PCI_VPD_DATA: u32 = 4;
pub const PCI_CAP_VPD_SIZEOF: u32 = 8;
pub const PCI_SID_ESR: u32 = 2;
pub const PCI_SID_ESR_NSLOTS: u32 = 31;
pub const PCI_SID_ESR_FIC: u32 = 32;
pub const PCI_SID_CHASSIS_NR: u32 = 3;
pub const PCI_MSI_FLAGS: u32 = 2;
pub const PCI_MSI_FLAGS_ENABLE: u32 = 1;
pub const PCI_MSI_FLAGS_QMASK: u32 = 14;
pub const PCI_MSI_FLAGS_QSIZE: u32 = 112;
pub const PCI_MSI_FLAGS_64BIT: u32 = 128;
pub const PCI_MSI_FLAGS_MASKBIT: u32 = 256;
pub const PCI_MSI_RFU: u32 = 3;
pub const PCI_MSI_ADDRESS_LO: u32 = 4;
pub const PCI_MSI_ADDRESS_HI: u32 = 8;
pub const PCI_MSI_DATA_32: u32 = 8;
pub const PCI_MSI_MASK_32: u32 = 12;
pub const PCI_MSI_PENDING_32: u32 = 16;
pub const PCI_MSI_DATA_64: u32 = 12;
pub const PCI_MSI_MASK_64: u32 = 16;
pub const PCI_MSI_PENDING_64: u32 = 20;
pub const PCI_MSIX_FLAGS: u32 = 2;
pub const PCI_MSIX_FLAGS_QSIZE: u32 = 2047;
pub const PCI_MSIX_FLAGS_MASKALL: u32 = 16384;
pub const PCI_MSIX_FLAGS_ENABLE: u32 = 32768;
pub const PCI_MSIX_TABLE: u32 = 4;
pub const PCI_MSIX_TABLE_BIR: u32 = 7;
pub const PCI_MSIX_TABLE_OFFSET: u32 = 4294967288;
pub const PCI_MSIX_PBA: u32 = 8;
pub const PCI_MSIX_PBA_BIR: u32 = 7;
pub const PCI_MSIX_PBA_OFFSET: u32 = 4294967288;
pub const PCI_MSIX_FLAGS_BIRMASK: u32 = 7;
pub const PCI_CAP_MSIX_SIZEOF: u32 = 12;
pub const PCI_MSIX_ENTRY_SIZE: u32 = 16;
pub const PCI_MSIX_ENTRY_LOWER_ADDR: u32 = 0;
pub const PCI_MSIX_ENTRY_UPPER_ADDR: u32 = 4;
pub const PCI_MSIX_ENTRY_DATA: u32 = 8;
pub const PCI_MSIX_ENTRY_VECTOR_CTRL: u32 = 12;
pub const PCI_MSIX_ENTRY_CTRL_MASKBIT: u32 = 1;
pub const PCI_CHSWP_CSR: u32 = 2;
pub const PCI_CHSWP_DHA: u32 = 1;
pub const PCI_CHSWP_EIM: u32 = 2;
pub const PCI_CHSWP_PIE: u32 = 4;
pub const PCI_CHSWP_LOO: u32 = 8;
pub const PCI_CHSWP_PI: u32 = 48;
pub const PCI_CHSWP_EXT: u32 = 64;
pub const PCI_CHSWP_INS: u32 = 128;
pub const PCI_AF_LENGTH: u32 = 2;
pub const PCI_AF_CAP: u32 = 3;
pub const PCI_AF_CAP_TP: u32 = 1;
pub const PCI_AF_CAP_FLR: u32 = 2;
pub const PCI_AF_CTRL: u32 = 4;
pub const PCI_AF_CTRL_FLR: u32 = 1;
pub const PCI_AF_STATUS: u32 = 5;
pub const PCI_AF_STATUS_TP: u32 = 1;
pub const PCI_CAP_AF_SIZEOF: u32 = 6;
pub const PCI_EA_NUM_ENT: u32 = 2;
pub const PCI_EA_NUM_ENT_MASK: u32 = 63;
pub const PCI_EA_FIRST_ENT: u32 = 4;
pub const PCI_EA_FIRST_ENT_BRIDGE: u32 = 8;
pub const PCI_EA_ES: u32 = 7;
pub const PCI_EA_BEI: u32 = 240;
pub const PCI_EA_SEC_BUS_MASK: u32 = 255;
pub const PCI_EA_SUB_BUS_MASK: u32 = 65280;
pub const PCI_EA_SUB_BUS_SHIFT: u32 = 8;
pub const PCI_EA_BEI_BAR0: u32 = 0;
pub const PCI_EA_BEI_BAR5: u32 = 5;
pub const PCI_EA_BEI_BRIDGE: u32 = 6;
pub const PCI_EA_BEI_ENI: u32 = 7;
pub const PCI_EA_BEI_ROM: u32 = 8;
pub const PCI_EA_BEI_VF_BAR0: u32 = 9;
pub const PCI_EA_BEI_VF_BAR5: u32 = 14;
pub const PCI_EA_BEI_RESERVED: u32 = 15;
pub const PCI_EA_PP: u32 = 65280;
pub const PCI_EA_SP: u32 = 16711680;
pub const PCI_EA_P_MEM: u32 = 0;
pub const PCI_EA_P_MEM_PREFETCH: u32 = 1;
pub const PCI_EA_P_IO: u32 = 2;
pub const PCI_EA_P_VF_MEM_PREFETCH: u32 = 3;
pub const PCI_EA_P_VF_MEM: u32 = 4;
pub const PCI_EA_P_BRIDGE_MEM: u32 = 5;
pub const PCI_EA_P_BRIDGE_MEM_PREFETCH: u32 = 6;
pub const PCI_EA_P_BRIDGE_IO: u32 = 7;
pub const PCI_EA_P_MEM_RESERVED: u32 = 253;
pub const PCI_EA_P_IO_RESERVED: u32 = 254;
pub const PCI_EA_P_UNAVAILABLE: u32 = 255;
pub const PCI_EA_WRITABLE: u32 = 1073741824;
pub const PCI_EA_ENABLE: u32 = 2147483648;
pub const PCI_EA_BASE: u32 = 4;
pub const PCI_EA_MAX_OFFSET: u32 = 8;
pub const PCI_EA_IS_64: u32 = 2;
pub const PCI_EA_FIELD_MASK: u32 = 4294967292;
pub const PCI_X_CMD: u32 = 2;
pub const PCI_X_CMD_DPERR_E: u32 = 1;
pub const PCI_X_CMD_ERO: u32 = 2;
pub const PCI_X_CMD_READ_512: u32 = 0;
pub const PCI_X_CMD_READ_1K: u32 = 4;
pub const PCI_X_CMD_READ_2K: u32 = 8;
pub const PCI_X_CMD_READ_4K: u32 = 12;
pub const PCI_X_CMD_MAX_READ: u32 = 12;
pub const PCI_X_CMD_SPLIT_1: u32 = 0;
pub const PCI_X_CMD_SPLIT_2: u32 = 16;
pub const PCI_X_CMD_SPLIT_3: u32 = 32;
pub const PCI_X_CMD_SPLIT_4: u32 = 48;
pub const PCI_X_CMD_SPLIT_8: u32 = 64;
pub const PCI_X_CMD_SPLIT_12: u32 = 80;
pub const PCI_X_CMD_SPLIT_16: u32 = 96;
pub const PCI_X_CMD_SPLIT_32: u32 = 112;
pub const PCI_X_CMD_MAX_SPLIT: u32 = 112;
pub const PCI_X_STATUS: u32 = 4;
pub const PCI_X_STATUS_DEVFN: u32 = 255;
pub const PCI_X_STATUS_BUS: u32 = 65280;
pub const PCI_X_STATUS_64BIT: u32 = 65536;
pub const PCI_X_STATUS_133MHZ: u32 = 131072;
pub const PCI_X_STATUS_SPL_DISC: u32 = 262144;
pub const PCI_X_STATUS_UNX_SPL: u32 = 524288;
pub const PCI_X_STATUS_COMPLEX: u32 = 1048576;
pub const PCI_X_STATUS_MAX_READ: u32 = 6291456;
pub const PCI_X_STATUS_MAX_SPLIT: u32 = 58720256;
pub const PCI_X_STATUS_MAX_CUM: u32 = 469762048;
pub const PCI_X_STATUS_SPL_ERR: u32 = 536870912;
pub const PCI_X_STATUS_266MHZ: u32 = 1073741824;
pub const PCI_X_STATUS_533MHZ: u32 = 2147483648;
pub const PCI_X_ECC_CSR: u32 = 8;
pub const PCI_CAP_PCIX_SIZEOF_V0: u32 = 8;
pub const PCI_CAP_PCIX_SIZEOF_V1: u32 = 24;
pub const PCI_CAP_PCIX_SIZEOF_V2: u32 = 24;
pub const PCI_X_BRIDGE_SSTATUS: u32 = 2;
pub const PCI_X_SSTATUS_64BIT: u32 = 1;
pub const PCI_X_SSTATUS_133MHZ: u32 = 2;
pub const PCI_X_SSTATUS_FREQ: u32 = 960;
pub const PCI_X_SSTATUS_VERS: u32 = 12288;
pub const PCI_X_SSTATUS_V1: u32 = 4096;
pub const PCI_X_SSTATUS_V2: u32 = 8192;
pub const PCI_X_SSTATUS_266MHZ: u32 = 16384;
pub const PCI_X_SSTATUS_533MHZ: u32 = 32768;
pub const PCI_X_BRIDGE_STATUS: u32 = 4;
pub const PCI_SSVID_VENDOR_ID: u32 = 4;
pub const PCI_SSVID_DEVICE_ID: u32 = 6;
pub const PCI_EXP_FLAGS: u32 = 2;
pub const PCI_EXP_FLAGS_VERS: u32 = 15;
pub const PCI_EXP_FLAGS_TYPE: u32 = 240;
pub const PCI_EXP_TYPE_ENDPOINT: u32 = 0;
pub const PCI_EXP_TYPE_LEG_END: u32 = 1;
pub const PCI_EXP_TYPE_ROOT_PORT: u32 = 4;
pub const PCI_EXP_TYPE_UPSTREAM: u32 = 5;
pub const PCI_EXP_TYPE_DOWNSTREAM: u32 = 6;
pub const PCI_EXP_TYPE_PCI_BRIDGE: u32 = 7;
pub const PCI_EXP_TYPE_PCIE_BRIDGE: u32 = 8;
pub const PCI_EXP_TYPE_RC_END: u32 = 9;
pub const PCI_EXP_TYPE_RC_EC: u32 = 10;
pub const PCI_EXP_FLAGS_SLOT: u32 = 256;
pub const PCI_EXP_FLAGS_IRQ: u32 = 15872;
pub const PCI_EXP_DEVCAP: u32 = 4;
pub const PCI_EXP_DEVCAP_PAYLOAD: u32 = 7;
pub const PCI_EXP_DEVCAP_PHANTOM: u32 = 24;
pub const PCI_EXP_DEVCAP_EXT_TAG: u32 = 32;
pub const PCI_EXP_DEVCAP_L0S: u32 = 448;
pub const PCI_EXP_DEVCAP_L1: u32 = 3584;
pub const PCI_EXP_DEVCAP_ATN_BUT: u32 = 4096;
pub const PCI_EXP_DEVCAP_ATN_IND: u32 = 8192;
pub const PCI_EXP_DEVCAP_PWR_IND: u32 = 16384;
pub const PCI_EXP_DEVCAP_RBER: u32 = 32768;
pub const PCI_EXP_DEVCAP_PWR_VAL: u32 = 66846720;
pub const PCI_EXP_DEVCAP_PWR_SCL: u32 = 201326592;
pub const PCI_EXP_DEVCAP_FLR: u32 = 268435456;
pub const PCI_EXP_DEVCTL: u32 = 8;
pub const PCI_EXP_DEVCTL_CERE: u32 = 1;
pub const PCI_EXP_DEVCTL_NFERE: u32 = 2;
pub const PCI_EXP_DEVCTL_FERE: u32 = 4;
pub const PCI_EXP_DEVCTL_URRE: u32 = 8;
pub const PCI_EXP_DEVCTL_RELAX_EN: u32 = 16;
pub const PCI_EXP_DEVCTL_PAYLOAD: u32 = 224;
pub const PCI_EXP_DEVCTL_EXT_TAG: u32 = 256;
pub const PCI_EXP_DEVCTL_PHANTOM: u32 = 512;
pub const PCI_EXP_DEVCTL_AUX_PME: u32 = 1024;
pub const PCI_EXP_DEVCTL_NOSNOOP_EN: u32 = 2048;
pub const PCI_EXP_DEVCTL_READRQ: u32 = 28672;
pub const PCI_EXP_DEVCTL_READRQ_128B: u32 = 0;
pub const PCI_EXP_DEVCTL_READRQ_256B: u32 = 4096;
pub const PCI_EXP_DEVCTL_READRQ_512B: u32 = 8192;
pub const PCI_EXP_DEVCTL_READRQ_1024B: u32 = 12288;
pub const PCI_EXP_DEVCTL_READRQ_2048B: u32 = 16384;
pub const PCI_EXP_DEVCTL_READRQ_4096B: u32 = 20480;
pub const PCI_EXP_DEVCTL_BCR_FLR: u32 = 32768;
pub const PCI_EXP_DEVSTA: u32 = 10;
pub const PCI_EXP_DEVSTA_CED: u32 = 1;
pub const PCI_EXP_DEVSTA_NFED: u32 = 2;
pub const PCI_EXP_DEVSTA_FED: u32 = 4;
pub const PCI_EXP_DEVSTA_URD: u32 = 8;
pub const PCI_EXP_DEVSTA_AUXPD: u32 = 16;
pub const PCI_EXP_DEVSTA_TRPND: u32 = 32;
pub const PCI_CAP_EXP_RC_ENDPOINT_SIZEOF_V1: u32 = 12;
pub const PCI_EXP_LNKCAP: u32 = 12;
pub const PCI_EXP_LNKCAP_SLS: u32 = 15;
pub const PCI_EXP_LNKCAP_SLS_2_5GB: u32 = 1;
pub const PCI_EXP_LNKCAP_SLS_5_0GB: u32 = 2;
pub const PCI_EXP_LNKCAP_SLS_8_0GB: u32 = 3;
pub const PCI_EXP_LNKCAP_SLS_16_0GB: u32 = 4;
pub const PCI_EXP_LNKCAP_SLS_32_0GB: u32 = 5;
pub const PCI_EXP_LNKCAP_SLS_64_0GB: u32 = 6;
pub const PCI_EXP_LNKCAP_MLW: u32 = 1008;
pub const PCI_EXP_LNKCAP_ASPMS: u32 = 3072;
pub const PCI_EXP_LNKCAP_ASPM_L0S: u32 = 1024;
pub const PCI_EXP_LNKCAP_ASPM_L1: u32 = 2048;
pub const PCI_EXP_LNKCAP_L0SEL: u32 = 28672;
pub const PCI_EXP_LNKCAP_L1EL: u32 = 229376;
pub const PCI_EXP_LNKCAP_CLKPM: u32 = 262144;
pub const PCI_EXP_LNKCAP_SDERC: u32 = 524288;
pub const PCI_EXP_LNKCAP_DLLLARC: u32 = 1048576;
pub const PCI_EXP_LNKCAP_LBNC: u32 = 2097152;
pub const PCI_EXP_LNKCAP_PN: u32 = 4278190080;
pub const PCI_EXP_LNKCTL: u32 = 16;
pub const PCI_EXP_LNKCTL_ASPMC: u32 = 3;
pub const PCI_EXP_LNKCTL_ASPM_L0S: u32 = 1;
pub const PCI_EXP_LNKCTL_ASPM_L1: u32 = 2;
pub const PCI_EXP_LNKCTL_RCB: u32 = 8;
pub const PCI_EXP_LNKCTL_LD: u32 = 16;
pub const PCI_EXP_LNKCTL_RL: u32 = 32;
pub const PCI_EXP_LNKCTL_CCC: u32 = 64;
pub const PCI_EXP_LNKCTL_ES: u32 = 128;
pub const PCI_EXP_LNKCTL_CLKREQ_EN: u32 = 256;
pub const PCI_EXP_LNKCTL_HAWD: u32 = 512;
pub const PCI_EXP_LNKCTL_LBMIE: u32 = 1024;
pub const PCI_EXP_LNKCTL_LABIE: u32 = 2048;
pub const PCI_EXP_LNKSTA: u32 = 18;
pub const PCI_EXP_LNKSTA_CLS: u32 = 15;
pub const PCI_EXP_LNKSTA_CLS_2_5GB: u32 = 1;
pub const PCI_EXP_LNKSTA_CLS_5_0GB: u32 = 2;
pub const PCI_EXP_LNKSTA_CLS_8_0GB: u32 = 3;
pub const PCI_EXP_LNKSTA_CLS_16_0GB: u32 = 4;
pub const PCI_EXP_LNKSTA_CLS_32_0GB: u32 = 5;
pub const PCI_EXP_LNKSTA_CLS_64_0GB: u32 = 6;
pub const PCI_EXP_LNKSTA_NLW: u32 = 1008;
pub const PCI_EXP_LNKSTA_NLW_X1: u32 = 16;
pub const PCI_EXP_LNKSTA_NLW_X2: u32 = 32;
pub const PCI_EXP_LNKSTA_NLW_X4: u32 = 64;
pub const PCI_EXP_LNKSTA_NLW_X8: u32 = 128;
pub const PCI_EXP_LNKSTA_NLW_SHIFT: u32 = 4;
pub const PCI_EXP_LNKSTA_LT: u32 = 2048;
pub const PCI_EXP_LNKSTA_SLC: u32 = 4096;
pub const PCI_EXP_LNKSTA_DLLLA: u32 = 8192;
pub const PCI_EXP_LNKSTA_LBMS: u32 = 16384;
pub const PCI_EXP_LNKSTA_LABS: u32 = 32768;
pub const PCI_CAP_EXP_ENDPOINT_SIZEOF_V1: u32 = 20;
pub const PCI_EXP_SLTCAP: u32 = 20;
pub const PCI_EXP_SLTCAP_ABP: u32 = 1;
pub const PCI_EXP_SLTCAP_PCP: u32 = 2;
pub const PCI_EXP_SLTCAP_MRLSP: u32 = 4;
pub const PCI_EXP_SLTCAP_AIP: u32 = 8;
pub const PCI_EXP_SLTCAP_PIP: u32 = 16;
pub const PCI_EXP_SLTCAP_HPS: u32 = 32;
pub const PCI_EXP_SLTCAP_HPC: u32 = 64;
pub const PCI_EXP_SLTCAP_SPLV: u32 = 32640;
pub const PCI_EXP_SLTCAP_SPLS: u32 = 98304;
pub const PCI_EXP_SLTCAP_EIP: u32 = 131072;
pub const PCI_EXP_SLTCAP_NCCS: u32 = 262144;
pub const PCI_EXP_SLTCAP_PSN: u32 = 4294443008;
pub const PCI_EXP_SLTCTL: u32 = 24;
pub const PCI_EXP_SLTCTL_ABPE: u32 = 1;
pub const PCI_EXP_SLTCTL_PFDE: u32 = 2;
pub const PCI_EXP_SLTCTL_MRLSCE: u32 = 4;
pub const PCI_EXP_SLTCTL_PDCE: u32 = 8;
pub const PCI_EXP_SLTCTL_CCIE: u32 = 16;
pub const PCI_EXP_SLTCTL_HPIE: u32 = 32;
pub const PCI_EXP_SLTCTL_AIC: u32 = 192;
pub const PCI_EXP_SLTCTL_ATTN_IND_SHIFT: u32 = 6;
pub const PCI_EXP_SLTCTL_ATTN_IND_ON: u32 = 64;
pub const PCI_EXP_SLTCTL_ATTN_IND_BLINK: u32 = 128;
pub const PCI_EXP_SLTCTL_ATTN_IND_OFF: u32 = 192;
pub const PCI_EXP_SLTCTL_PIC: u32 = 768;
pub const PCI_EXP_SLTCTL_PWR_IND_ON: u32 = 256;
pub const PCI_EXP_SLTCTL_PWR_IND_BLINK: u32 = 512;
pub const PCI_EXP_SLTCTL_PWR_IND_OFF: u32 = 768;
pub const PCI_EXP_SLTCTL_PCC: u32 = 1024;
pub const PCI_EXP_SLTCTL_PWR_ON: u32 = 0;
pub const PCI_EXP_SLTCTL_PWR_OFF: u32 = 1024;
pub const PCI_EXP_SLTCTL_EIC: u32 = 2048;
pub const PCI_EXP_SLTCTL_DLLSCE: u32 = 4096;
pub const PCI_EXP_SLTCTL_IBPD_DISABLE: u32 = 16384;
pub const PCI_EXP_SLTSTA: u32 = 26;
pub const PCI_EXP_SLTSTA_ABP: u32 = 1;
pub const PCI_EXP_SLTSTA_PFD: u32 = 2;
pub const PCI_EXP_SLTSTA_MRLSC: u32 = 4;
pub const PCI_EXP_SLTSTA_PDC: u32 = 8;
pub const PCI_EXP_SLTSTA_CC: u32 = 16;
pub const PCI_EXP_SLTSTA_MRLSS: u32 = 32;
pub const PCI_EXP_SLTSTA_PDS: u32 = 64;
pub const PCI_EXP_SLTSTA_EIS: u32 = 128;
pub const PCI_EXP_SLTSTA_DLLSC: u32 = 256;
pub const PCI_EXP_RTCTL: u32 = 28;
pub const PCI_EXP_RTCTL_SECEE: u32 = 1;
pub const PCI_EXP_RTCTL_SENFEE: u32 = 2;
pub const PCI_EXP_RTCTL_SEFEE: u32 = 4;
pub const PCI_EXP_RTCTL_PMEIE: u32 = 8;
pub const PCI_EXP_RTCTL_CRSSVE: u32 = 16;
pub const PCI_EXP_RTCAP: u32 = 30;
pub const PCI_EXP_RTCAP_CRSVIS: u32 = 1;
pub const PCI_EXP_RTSTA: u32 = 32;
pub const PCI_EXP_RTSTA_PME: u32 = 65536;
pub const PCI_EXP_RTSTA_PENDING: u32 = 131072;
pub const PCI_EXP_DEVCAP2: u32 = 36;
pub const PCI_EXP_DEVCAP2_COMP_TMOUT_DIS: u32 = 16;
pub const PCI_EXP_DEVCAP2_ARI: u32 = 32;
pub const PCI_EXP_DEVCAP2_ATOMIC_ROUTE: u32 = 64;
pub const PCI_EXP_DEVCAP2_ATOMIC_COMP32: u32 = 128;
pub const PCI_EXP_DEVCAP2_ATOMIC_COMP64: u32 = 256;
pub const PCI_EXP_DEVCAP2_ATOMIC_COMP128: u32 = 512;
pub const PCI_EXP_DEVCAP2_LTR: u32 = 2048;
pub const PCI_EXP_DEVCAP2_OBFF_MASK: u32 = 786432;
pub const PCI_EXP_DEVCAP2_OBFF_MSG: u32 = 262144;
pub const PCI_EXP_DEVCAP2_OBFF_WAKE: u32 = 524288;
pub const PCI_EXP_DEVCAP2_EE_PREFIX: u32 = 2097152;
pub const PCI_EXP_DEVCTL2: u32 = 40;
pub const PCI_EXP_DEVCTL2_COMP_TIMEOUT: u32 = 15;
pub const PCI_EXP_DEVCTL2_COMP_TMOUT_DIS: u32 = 16;
pub const PCI_EXP_DEVCTL2_ARI: u32 = 32;
pub const PCI_EXP_DEVCTL2_ATOMIC_REQ: u32 = 64;
pub const PCI_EXP_DEVCTL2_ATOMIC_EGRESS_BLOCK: u32 = 128;
pub const PCI_EXP_DEVCTL2_IDO_REQ_EN: u32 = 256;
pub const PCI_EXP_DEVCTL2_IDO_CMP_EN: u32 = 512;
pub const PCI_EXP_DEVCTL2_LTR_EN: u32 = 1024;
pub const PCI_EXP_DEVCTL2_OBFF_MSGA_EN: u32 = 8192;
pub const PCI_EXP_DEVCTL2_OBFF_MSGB_EN: u32 = 16384;
pub const PCI_EXP_DEVCTL2_OBFF_WAKE_EN: u32 = 24576;
pub const PCI_EXP_DEVSTA2: u32 = 42;
pub const PCI_CAP_EXP_RC_ENDPOINT_SIZEOF_V2: u32 = 44;
pub const PCI_EXP_LNKCAP2: u32 = 44;
pub const PCI_EXP_LNKCAP2_SLS_2_5GB: u32 = 2;
pub const PCI_EXP_LNKCAP2_SLS_5_0GB: u32 = 4;
pub const PCI_EXP_LNKCAP2_SLS_8_0GB: u32 = 8;
pub const PCI_EXP_LNKCAP2_SLS_16_0GB: u32 = 16;
pub const PCI_EXP_LNKCAP2_SLS_32_0GB: u32 = 32;
pub const PCI_EXP_LNKCAP2_SLS_64_0GB: u32 = 64;
pub const PCI_EXP_LNKCAP2_CROSSLINK: u32 = 256;
pub const PCI_EXP_LNKCTL2: u32 = 48;
pub const PCI_EXP_LNKCTL2_TLS: u32 = 15;
pub const PCI_EXP_LNKCTL2_TLS_2_5GT: u32 = 1;
pub const PCI_EXP_LNKCTL2_TLS_5_0GT: u32 = 2;
pub const PCI_EXP_LNKCTL2_TLS_8_0GT: u32 = 3;
pub const PCI_EXP_LNKCTL2_TLS_16_0GT: u32 = 4;
pub const PCI_EXP_LNKCTL2_TLS_32_0GT: u32 = 5;
pub const PCI_EXP_LNKCTL2_TLS_64_0GT: u32 = 6;
pub const PCI_EXP_LNKCTL2_ENTER_COMP: u32 = 16;
pub const PCI_EXP_LNKCTL2_TX_MARGIN: u32 = 896;
pub const PCI_EXP_LNKCTL2_HASD: u32 = 32;
pub const PCI_EXP_LNKSTA2: u32 = 50;
pub const PCI_CAP_EXP_ENDPOINT_SIZEOF_V2: u32 = 52;
pub const PCI_EXP_SLTCAP2: u32 = 52;
pub const PCI_EXP_SLTCAP2_IBPD: u32 = 1;
pub const PCI_EXP_SLTCTL2: u32 = 56;
pub const PCI_EXP_SLTSTA2: u32 = 58;
pub const PCI_EXT_CAP_ID_ERR: u32 = 1;
pub const PCI_EXT_CAP_ID_VC: u32 = 2;
pub const PCI_EXT_CAP_ID_DSN: u32 = 3;
pub const PCI_EXT_CAP_ID_PWR: u32 = 4;
pub const PCI_EXT_CAP_ID_RCLD: u32 = 5;
pub const PCI_EXT_CAP_ID_RCILC: u32 = 6;
pub const PCI_EXT_CAP_ID_RCEC: u32 = 7;
pub const PCI_EXT_CAP_ID_MFVC: u32 = 8;
pub const PCI_EXT_CAP_ID_VC9: u32 = 9;
pub const PCI_EXT_CAP_ID_RCRB: u32 = 10;
pub const PCI_EXT_CAP_ID_VNDR: u32 = 11;
pub const PCI_EXT_CAP_ID_CAC: u32 = 12;
pub const PCI_EXT_CAP_ID_ACS: u32 = 13;
pub const PCI_EXT_CAP_ID_ARI: u32 = 14;
pub const PCI_EXT_CAP_ID_ATS: u32 = 15;
pub const PCI_EXT_CAP_ID_SRIOV: u32 = 16;
pub const PCI_EXT_CAP_ID_MRIOV: u32 = 17;
pub const PCI_EXT_CAP_ID_MCAST: u32 = 18;
pub const PCI_EXT_CAP_ID_PRI: u32 = 19;
pub const PCI_EXT_CAP_ID_AMD_XXX: u32 = 20;
pub const PCI_EXT_CAP_ID_REBAR: u32 = 21;
pub const PCI_EXT_CAP_ID_DPA: u32 = 22;
pub const PCI_EXT_CAP_ID_TPH: u32 = 23;
pub const PCI_EXT_CAP_ID_LTR: u32 = 24;
pub const PCI_EXT_CAP_ID_SECPCI: u32 = 25;
pub const PCI_EXT_CAP_ID_PMUX: u32 = 26;
pub const PCI_EXT_CAP_ID_PASID: u32 = 27;
pub const PCI_EXT_CAP_ID_DPC: u32 = 29;
pub const PCI_EXT_CAP_ID_L1SS: u32 = 30;
pub const PCI_EXT_CAP_ID_PTM: u32 = 31;
pub const PCI_EXT_CAP_ID_DVSEC: u32 = 35;
pub const PCI_EXT_CAP_ID_DLF: u32 = 37;
pub const PCI_EXT_CAP_ID_PL_16GT: u32 = 38;
pub const PCI_EXT_CAP_ID_MAX: u32 = 38;
pub const PCI_EXT_CAP_DSN_SIZEOF: u32 = 12;
pub const PCI_EXT_CAP_MCAST_ENDPOINT_SIZEOF: u32 = 40;
pub const PCI_ERR_UNCOR_STATUS: u32 = 4;
pub const PCI_ERR_UNC_UND: u32 = 1;
pub const PCI_ERR_UNC_DLP: u32 = 16;
pub const PCI_ERR_UNC_SURPDN: u32 = 32;
pub const PCI_ERR_UNC_POISON_TLP: u32 = 4096;
pub const PCI_ERR_UNC_FCP: u32 = 8192;
pub const PCI_ERR_UNC_COMP_TIME: u32 = 16384;
pub const PCI_ERR_UNC_COMP_ABORT: u32 = 32768;
pub const PCI_ERR_UNC_UNX_COMP: u32 = 65536;
pub const PCI_ERR_UNC_RX_OVER: u32 = 131072;
pub const PCI_ERR_UNC_MALF_TLP: u32 = 262144;
pub const PCI_ERR_UNC_ECRC: u32 = 524288;
pub const PCI_ERR_UNC_UNSUP: u32 = 1048576;
pub const PCI_ERR_UNC_ACSV: u32 = 2097152;
pub const PCI_ERR_UNC_INTN: u32 = 4194304;
pub const PCI_ERR_UNC_MCBTLP: u32 = 8388608;
pub const PCI_ERR_UNC_ATOMEG: u32 = 16777216;
pub const PCI_ERR_UNC_TLPPRE: u32 = 33554432;
pub const PCI_ERR_UNCOR_MASK: u32 = 8;
pub const PCI_ERR_UNCOR_SEVER: u32 = 12;
pub const PCI_ERR_COR_STATUS: u32 = 16;
pub const PCI_ERR_COR_RCVR: u32 = 1;
pub const PCI_ERR_COR_BAD_TLP: u32 = 64;
pub const PCI_ERR_COR_BAD_DLLP: u32 = 128;
pub const PCI_ERR_COR_REP_ROLL: u32 = 256;
pub const PCI_ERR_COR_REP_TIMER: u32 = 4096;
pub const PCI_ERR_COR_ADV_NFAT: u32 = 8192;
pub const PCI_ERR_COR_INTERNAL: u32 = 16384;
pub const PCI_ERR_COR_LOG_OVER: u32 = 32768;
pub const PCI_ERR_COR_MASK: u32 = 20;
pub const PCI_ERR_CAP: u32 = 24;
pub const PCI_ERR_CAP_ECRC_GENC: u32 = 32;
pub const PCI_ERR_CAP_ECRC_GENE: u32 = 64;
pub const PCI_ERR_CAP_ECRC_CHKC: u32 = 128;
pub const PCI_ERR_CAP_ECRC_CHKE: u32 = 256;
pub const PCI_ERR_HEADER_LOG: u32 = 28;
pub const PCI_ERR_ROOT_COMMAND: u32 = 44;
pub const PCI_ERR_ROOT_CMD_COR_EN: u32 = 1;
pub const PCI_ERR_ROOT_CMD_NONFATAL_EN: u32 = 2;
pub const PCI_ERR_ROOT_CMD_FATAL_EN: u32 = 4;
pub const PCI_ERR_ROOT_STATUS: u32 = 48;
pub const PCI_ERR_ROOT_COR_RCV: u32 = 1;
pub const PCI_ERR_ROOT_MULTI_COR_RCV: u32 = 2;
pub const PCI_ERR_ROOT_UNCOR_RCV: u32 = 4;
pub const PCI_ERR_ROOT_MULTI_UNCOR_RCV: u32 = 8;
pub const PCI_ERR_ROOT_FIRST_FATAL: u32 = 16;
pub const PCI_ERR_ROOT_NONFATAL_RCV: u32 = 32;
pub const PCI_ERR_ROOT_FATAL_RCV: u32 = 64;
pub const PCI_ERR_ROOT_AER_IRQ: u32 = 4160749568;
pub const PCI_ERR_ROOT_ERR_SRC: u32 = 52;
pub const PCI_VC_PORT_CAP1: u32 = 4;
pub const PCI_VC_CAP1_EVCC: u32 = 7;
pub const PCI_VC_CAP1_LPEVCC: u32 = 112;
pub const PCI_VC_CAP1_ARB_SIZE: u32 = 3072;
pub const PCI_VC_PORT_CAP2: u32 = 8;
pub const PCI_VC_CAP2_32_PHASE: u32 = 2;
pub const PCI_VC_CAP2_64_PHASE: u32 = 4;
pub const PCI_VC_CAP2_128_PHASE: u32 = 8;
pub const PCI_VC_CAP2_ARB_OFF: u32 = 4278190080;
pub const PCI_VC_PORT_CTRL: u32 = 12;
pub const PCI_VC_PORT_CTRL_LOAD_TABLE: u32 = 1;
pub const PCI_VC_PORT_STATUS: u32 = 14;
pub const PCI_VC_PORT_STATUS_TABLE: u32 = 1;
pub const PCI_VC_RES_CAP: u32 = 16;
pub const PCI_VC_RES_CAP_32_PHASE: u32 = 2;
pub const PCI_VC_RES_CAP_64_PHASE: u32 = 4;
pub const PCI_VC_RES_CAP_128_PHASE: u32 = 8;
pub const PCI_VC_RES_CAP_128_PHASE_TB: u32 = 16;
pub const PCI_VC_RES_CAP_256_PHASE: u32 = 32;
pub const PCI_VC_RES_CAP_ARB_OFF: u32 = 4278190080;
pub const PCI_VC_RES_CTRL: u32 = 20;
pub const PCI_VC_RES_CTRL_LOAD_TABLE: u32 = 65536;
pub const PCI_VC_RES_CTRL_ARB_SELECT: u32 = 917504;
pub const PCI_VC_RES_CTRL_ID: u32 = 117440512;
pub const PCI_VC_RES_CTRL_ENABLE: u32 = 2147483648;
pub const PCI_VC_RES_STATUS: u32 = 26;
pub const PCI_VC_RES_STATUS_TABLE: u32 = 1;
pub const PCI_VC_RES_STATUS_NEGO: u32 = 2;
pub const PCI_CAP_VC_BASE_SIZEOF: u32 = 16;
pub const PCI_CAP_VC_PER_VC_SIZEOF: u32 = 12;
pub const PCI_PWR_DSR: u32 = 4;
pub const PCI_PWR_DATA: u32 = 8;
pub const PCI_PWR_CAP: u32 = 12;
pub const PCI_EXT_CAP_PWR_SIZEOF: u32 = 16;
pub const PCI_RCEC_RCIEP_BITMAP: u32 = 4;
pub const PCI_RCEC_BUSN: u32 = 8;
pub const PCI_RCEC_BUSN_REG_VER: u32 = 2;
pub const PCI_VNDR_HEADER: u32 = 4;
pub const HT_3BIT_CAP_MASK: u32 = 224;
pub const HT_CAPTYPE_SLAVE: u32 = 0;
pub const HT_CAPTYPE_HOST: u32 = 32;
pub const HT_5BIT_CAP_MASK: u32 = 248;
pub const HT_CAPTYPE_IRQ: u32 = 128;
pub const HT_CAPTYPE_REMAPPING_40: u32 = 160;
pub const HT_CAPTYPE_REMAPPING_64: u32 = 162;
pub const HT_CAPTYPE_UNITID_CLUMP: u32 = 144;
pub const HT_CAPTYPE_EXTCONF: u32 = 152;
pub const HT_CAPTYPE_MSI_MAPPING: u32 = 168;
pub const HT_MSI_FLAGS: u32 = 2;
pub const HT_MSI_FLAGS_ENABLE: u32 = 1;
pub const HT_MSI_FLAGS_FIXED: u32 = 2;
pub const HT_MSI_FIXED_ADDR: u32 = 4276092928;
pub const HT_MSI_ADDR_LO: u32 = 4;
pub const HT_MSI_ADDR_LO_MASK: u32 = 4293918720;
pub const HT_MSI_ADDR_HI: u32 = 8;
pub const HT_CAPTYPE_DIRECT_ROUTE: u32 = 176;
pub const HT_CAPTYPE_VCSET: u32 = 184;
pub const HT_CAPTYPE_ERROR_RETRY: u32 = 192;
pub const HT_CAPTYPE_GEN3: u32 = 208;
pub const HT_CAPTYPE_PM: u32 = 224;
pub const HT_CAP_SIZEOF_LONG: u32 = 28;
pub const HT_CAP_SIZEOF_SHORT: u32 = 24;
pub const PCI_ARI_CAP: u32 = 4;
pub const PCI_ARI_CAP_MFVC: u32 = 1;
pub const PCI_ARI_CAP_ACS: u32 = 2;
pub const PCI_ARI_CTRL: u32 = 6;
pub const PCI_ARI_CTRL_MFVC: u32 = 1;
pub const PCI_ARI_CTRL_ACS: u32 = 2;
pub const PCI_EXT_CAP_ARI_SIZEOF: u32 = 8;
pub const PCI_ATS_CAP: u32 = 4;
pub const PCI_ATS_MAX_QDEP: u32 = 32;
pub const PCI_ATS_CAP_PAGE_ALIGNED: u32 = 32;
pub const PCI_ATS_CTRL: u32 = 6;
pub const PCI_ATS_CTRL_ENABLE: u32 = 32768;
pub const PCI_ATS_MIN_STU: u32 = 12;
pub const PCI_EXT_CAP_ATS_SIZEOF: u32 = 8;
pub const PCI_PRI_CTRL: u32 = 4;
pub const PCI_PRI_CTRL_ENABLE: u32 = 1;
pub const PCI_PRI_CTRL_RESET: u32 = 2;
pub const PCI_PRI_STATUS: u32 = 6;
pub const PCI_PRI_STATUS_RF: u32 = 1;
pub const PCI_PRI_STATUS_UPRGI: u32 = 2;
pub const PCI_PRI_STATUS_STOPPED: u32 = 256;
pub const PCI_PRI_STATUS_PASID: u32 = 32768;
pub const PCI_PRI_MAX_REQ: u32 = 8;
pub const PCI_PRI_ALLOC_REQ: u32 = 12;
pub const PCI_EXT_CAP_PRI_SIZEOF: u32 = 16;
pub const PCI_PASID_CAP: u32 = 4;
pub const PCI_PASID_CAP_EXEC: u32 = 2;
pub const PCI_PASID_CAP_PRIV: u32 = 4;
pub const PCI_PASID_CTRL: u32 = 6;
pub const PCI_PASID_CTRL_ENABLE: u32 = 1;
pub const PCI_PASID_CTRL_EXEC: u32 = 2;
pub const PCI_PASID_CTRL_PRIV: u32 = 4;
pub const PCI_EXT_CAP_PASID_SIZEOF: u32 = 8;
pub const PCI_SRIOV_CAP: u32 = 4;
pub const PCI_SRIOV_CAP_VFM: u32 = 1;
pub const PCI_SRIOV_CTRL: u32 = 8;
pub const PCI_SRIOV_CTRL_VFE: u32 = 1;
pub const PCI_SRIOV_CTRL_VFM: u32 = 2;
pub const PCI_SRIOV_CTRL_INTR: u32 = 4;
pub const PCI_SRIOV_CTRL_MSE: u32 = 8;
pub const PCI_SRIOV_CTRL_ARI: u32 = 16;
pub const PCI_SRIOV_STATUS: u32 = 10;
pub const PCI_SRIOV_STATUS_VFM: u32 = 1;
pub const PCI_SRIOV_INITIAL_VF: u32 = 12;
pub const PCI_SRIOV_TOTAL_VF: u32 = 14;
pub const PCI_SRIOV_NUM_VF: u32 = 16;
pub const PCI_SRIOV_FUNC_LINK: u32 = 18;
pub const PCI_SRIOV_VF_OFFSET: u32 = 20;
pub const PCI_SRIOV_VF_STRIDE: u32 = 22;
pub const PCI_SRIOV_VF_DID: u32 = 26;
pub const PCI_SRIOV_SUP_PGSIZE: u32 = 28;
pub const PCI_SRIOV_SYS_PGSIZE: u32 = 32;
pub const PCI_SRIOV_BAR: u32 = 36;
pub const PCI_SRIOV_NUM_BARS: u32 = 6;
pub const PCI_SRIOV_VFM: u32 = 60;
pub const PCI_SRIOV_VFM_UA: u32 = 0;
pub const PCI_SRIOV_VFM_MI: u32 = 1;
pub const PCI_SRIOV_VFM_MO: u32 = 2;
pub const PCI_SRIOV_VFM_AV: u32 = 3;
pub const PCI_EXT_CAP_SRIOV_SIZEOF: u32 = 64;
pub const PCI_LTR_MAX_SNOOP_LAT: u32 = 4;
pub const PCI_LTR_MAX_NOSNOOP_LAT: u32 = 6;
pub const PCI_LTR_VALUE_MASK: u32 = 1023;
pub const PCI_LTR_SCALE_MASK: u32 = 7168;
pub const PCI_LTR_SCALE_SHIFT: u32 = 10;
pub const PCI_EXT_CAP_LTR_SIZEOF: u32 = 8;
pub const PCI_ACS_CAP: u32 = 4;
pub const PCI_ACS_SV: u32 = 1;
pub const PCI_ACS_TB: u32 = 2;
pub const PCI_ACS_RR: u32 = 4;
pub const PCI_ACS_CR: u32 = 8;
pub const PCI_ACS_UF: u32 = 16;
pub const PCI_ACS_EC: u32 = 32;
pub const PCI_ACS_DT: u32 = 64;
pub const PCI_ACS_EGRESS_BITS: u32 = 5;
pub const PCI_ACS_CTRL: u32 = 6;
pub const PCI_ACS_EGRESS_CTL_V: u32 = 8;
pub const PCI_VSEC_HDR: u32 = 4;
pub const PCI_VSEC_HDR_LEN_SHIFT: u32 = 20;
pub const PCI_SATA_REGS: u32 = 4;
pub const PCI_SATA_REGS_MASK: u32 = 15;
pub const PCI_SATA_REGS_INLINE: u32 = 15;
pub const PCI_SATA_SIZEOF_SHORT: u32 = 8;
pub const PCI_SATA_SIZEOF_LONG: u32 = 16;
pub const PCI_REBAR_CAP: u32 = 4;
pub const PCI_REBAR_CAP_SIZES: u32 = 16777200;
pub const PCI_REBAR_CTRL: u32 = 8;
pub const PCI_REBAR_CTRL_BAR_IDX: u32 = 7;
pub const PCI_REBAR_CTRL_NBAR_MASK: u32 = 224;
pub const PCI_REBAR_CTRL_NBAR_SHIFT: u32 = 5;
pub const PCI_REBAR_CTRL_BAR_SIZE: u32 = 7936;
pub const PCI_REBAR_CTRL_BAR_SHIFT: u32 = 8;
pub const PCI_DPA_CAP: u32 = 4;
pub const PCI_DPA_CAP_SUBSTATE_MASK: u32 = 31;
pub const PCI_DPA_BASE_SIZEOF: u32 = 16;
pub const PCI_TPH_CAP: u32 = 4;
pub const PCI_TPH_CAP_LOC_MASK: u32 = 1536;
pub const PCI_TPH_LOC_NONE: u32 = 0;
pub const PCI_TPH_LOC_CAP: u32 = 512;
pub const PCI_TPH_LOC_MSIX: u32 = 1024;
pub const PCI_TPH_CAP_ST_MASK: u32 = 134152192;
pub const PCI_TPH_CAP_ST_SHIFT: u32 = 16;
pub const PCI_TPH_BASE_SIZEOF: u32 = 12;
pub const PCI_EXP_DPC_CAP: u32 = 4;
pub const PCI_EXP_DPC_IRQ: u32 = 31;
pub const PCI_EXP_DPC_CAP_RP_EXT: u32 = 32;
pub const PCI_EXP_DPC_CAP_POISONED_TLP: u32 = 64;
pub const PCI_EXP_DPC_CAP_SW_TRIGGER: u32 = 128;
pub const PCI_EXP_DPC_RP_PIO_LOG_SIZE: u32 = 3840;
pub const PCI_EXP_DPC_CAP_DL_ACTIVE: u32 = 4096;
pub const PCI_EXP_DPC_CTL: u32 = 6;
pub const PCI_EXP_DPC_CTL_EN_FATAL: u32 = 1;
pub const PCI_EXP_DPC_CTL_EN_NONFATAL: u32 = 2;
pub const PCI_EXP_DPC_CTL_INT_EN: u32 = 8;
pub const PCI_EXP_DPC_STATUS: u32 = 8;
pub const PCI_EXP_DPC_STATUS_TRIGGER: u32 = 1;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN: u32 = 6;
pub const PCI_EXP_DPC_STATUS_INTERRUPT: u32 = 8;
pub const PCI_EXP_DPC_RP_BUSY: u32 = 16;
pub const PCI_EXP_DPC_STATUS_TRIGGER_RSN_EXT: u32 = 96;
pub const PCI_EXP_DPC_SOURCE_ID: u32 = 10;
pub const PCI_EXP_DPC_RP_PIO_STATUS: u32 = 12;
pub const PCI_EXP_DPC_RP_PIO_MASK: u32 = 16;
pub const PCI_EXP_DPC_RP_PIO_SEVERITY: u32 = 20;
pub const PCI_EXP_DPC_RP_PIO_SYSERROR: u32 = 24;
pub const PCI_EXP_DPC_RP_PIO_EXCEPTION: u32 = 28;
pub const PCI_EXP_DPC_RP_PIO_HEADER_LOG: u32 = 32;
pub const PCI_EXP_DPC_RP_PIO_IMPSPEC_LOG: u32 = 48;
pub const PCI_EXP_DPC_RP_PIO_TLPPREFIX_LOG: u32 = 52;
pub const PCI_PTM_CAP: u32 = 4;
pub const PCI_PTM_CAP_REQ: u32 = 1;
pub const PCI_PTM_CAP_ROOT: u32 = 4;
pub const PCI_PTM_GRANULARITY_MASK: u32 = 65280;
pub const PCI_PTM_CTRL: u32 = 8;
pub const PCI_PTM_CTRL_ENABLE: u32 = 1;
pub const PCI_PTM_CTRL_ROOT: u32 = 2;
pub const PCI_L1SS_CAP: u32 = 4;
pub const PCI_L1SS_CAP_PCIPM_L1_2: u32 = 1;
pub const PCI_L1SS_CAP_PCIPM_L1_1: u32 = 2;
pub const PCI_L1SS_CAP_ASPM_L1_2: u32 = 4;
pub const PCI_L1SS_CAP_ASPM_L1_1: u32 = 8;
pub const PCI_L1SS_CAP_L1_PM_SS: u32 = 16;
pub const PCI_L1SS_CAP_CM_RESTORE_TIME: u32 = 65280;
pub const PCI_L1SS_CAP_P_PWR_ON_SCALE: u32 = 196608;
pub const PCI_L1SS_CAP_P_PWR_ON_VALUE: u32 = 16252928;
pub const PCI_L1SS_CTL1: u32 = 8;
pub const PCI_L1SS_CTL1_PCIPM_L1_2: u32 = 1;
pub const PCI_L1SS_CTL1_PCIPM_L1_1: u32 = 2;
pub const PCI_L1SS_CTL1_ASPM_L1_2: u32 = 4;
pub const PCI_L1SS_CTL1_ASPM_L1_1: u32 = 8;
pub const PCI_L1SS_CTL1_L1_2_MASK: u32 = 5;
pub const PCI_L1SS_CTL1_L1SS_MASK: u32 = 15;
pub const PCI_L1SS_CTL1_CM_RESTORE_TIME: u32 = 65280;
pub const PCI_L1SS_CTL1_LTR_L12_TH_VALUE: u32 = 67043328;
pub const PCI_L1SS_CTL1_LTR_L12_TH_SCALE: u32 = 3758096384;
pub const PCI_L1SS_CTL2: u32 = 12;
pub const PCI_DVSEC_HEADER1: u32 = 4;
pub const PCI_DVSEC_HEADER2: u32 = 8;
pub const PCI_DLF_CAP: u32 = 4;
pub const PCI_DLF_EXCHANGE_ENABLE: u32 = 2147483648;
pub const PCI_PL_16GT_LE_CTRL: u32 = 32;
pub const PCI_PL_16GT_LE_CTRL_DSP_TX_PRESET_MASK: u32 = 15;
pub const PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_MASK: u32 = 240;
pub const PCI_PL_16GT_LE_CTRL_USP_TX_PRESET_SHIFT: u32 = 4;
pub const VFIO_USER_PCI_CAP_EXP_SIZEOF: u32 = 60;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const PCI_BARS_NR: u32 = 6;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const __BITS_PER_LONG: u32 = 64;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const VFIO_API_VERSION: u32 = 0;
pub const VFIO_TYPE1_IOMMU: u32 = 1;
pub const VFIO_SPAPR_TCE_IOMMU: u32 = 2;
pub const VFIO_TYPE1v2_IOMMU: u32 = 3;
pub const VFIO_DMA_CC_IOMMU: u32 = 4;
pub const VFIO_EEH: u32 = 5;
pub const VFIO_TYPE1_NESTING_IOMMU: u32 = 6;
pub const VFIO_SPAPR_TCE_v2_IOMMU: u32 = 7;
pub const VFIO_NOIOMMU_IOMMU: u32 = 8;
pub const VFIO_TYPE: u8 = 59u8;
pub const VFIO_BASE: u32 = 100;
pub const VFIO_GROUP_FLAGS_VIABLE: u32 = 1;
pub const VFIO_GROUP_FLAGS_CONTAINER_SET: u32 = 2;
pub const VFIO_DEVICE_FLAGS_RESET: u32 = 1;
pub const VFIO_DEVICE_FLAGS_PCI: u32 = 2;
pub const VFIO_DEVICE_FLAGS_PLATFORM: u32 = 4;
pub const VFIO_DEVICE_FLAGS_AMBA: u32 = 8;
pub const VFIO_DEVICE_FLAGS_CCW: u32 = 16;
pub const VFIO_DEVICE_FLAGS_AP: u32 = 32;
pub const VFIO_DEVICE_FLAGS_FSL_MC: u32 = 64;
pub const VFIO_DEVICE_FLAGS_CAPS: u32 = 128;
pub const VFIO_DEVICE_API_PCI_STRING: &'static [u8; 9usize] = b"vfio-pci\0";
pub const VFIO_DEVICE_API_PLATFORM_STRING: &'static [u8; 14usize] = b"vfio-platform\0";
pub const VFIO_DEVICE_API_AMBA_STRING: &'static [u8; 10usize] = b"vfio-amba\0";
pub const VFIO_DEVICE_API_CCW_STRING: &'static [u8; 9usize] = b"vfio-ccw\0";
pub const VFIO_DEVICE_API_AP_STRING: &'static [u8; 8usize] = b"vfio-ap\0";
pub const VFIO_DEVICE_INFO_CAP_ZPCI_BASE: u32 = 1;
pub const VFIO_DEVICE_INFO_CAP_ZPCI_GROUP: u32 = 2;
pub const VFIO_DEVICE_INFO_CAP_ZPCI_UTIL: u32 = 3;
pub const VFIO_DEVICE_INFO_CAP_ZPCI_PFIP: u32 = 4;
pub const VFIO_REGION_INFO_FLAG_READ: u32 = 1;
pub const VFIO_REGION_INFO_FLAG_WRITE: u32 = 2;
pub const VFIO_REGION_INFO_FLAG_MMAP: u32 = 4;
pub const VFIO_REGION_INFO_FLAG_CAPS: u32 = 8;
pub const VFIO_REGION_INFO_CAP_SPARSE_MMAP: u32 = 1;
pub const VFIO_REGION_INFO_CAP_TYPE: u32 = 2;
pub const VFIO_REGION_TYPE_PCI_VENDOR_TYPE: u32 = 2147483648;
pub const VFIO_REGION_TYPE_PCI_VENDOR_MASK: u32 = 65535;
pub const VFIO_REGION_TYPE_GFX: u32 = 1;
pub const VFIO_REGION_TYPE_CCW: u32 = 2;
pub const VFIO_REGION_TYPE_MIGRATION: u32 = 3;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION: u32 = 1;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG: u32 = 2;
pub const VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG: u32 = 3;
pub const VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM: u32 = 1;
pub const VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD: u32 = 1;
pub const VFIO_REGION_SUBTYPE_GFX_EDID: u32 = 1;
pub const VFIO_DEVICE_GFX_LINK_STATE_UP: u32 = 1;
pub const VFIO_DEVICE_GFX_LINK_STATE_DOWN: u32 = 2;
pub const VFIO_REGION_SUBTYPE_CCW_ASYNC_CMD: u32 = 1;
pub const VFIO_REGION_SUBTYPE_CCW_SCHIB: u32 = 2;
pub const VFIO_REGION_SUBTYPE_CCW_CRW: u32 = 3;
pub const VFIO_REGION_SUBTYPE_MIGRATION: u32 = 1;
pub const VFIO_DEVICE_STATE_STOP: u32 = 0;
pub const VFIO_DEVICE_STATE_RUNNING: u32 = 1;
pub const VFIO_DEVICE_STATE_SAVING: u32 = 2;
pub const VFIO_DEVICE_STATE_RESUMING: u32 = 4;
pub const VFIO_DEVICE_STATE_MASK: u32 = 7;
pub const VFIO_REGION_INFO_CAP_MSIX_MAPPABLE: u32 = 3;
pub const VFIO_REGION_INFO_CAP_NVLINK2_SSATGT: u32 = 4;
pub const VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD: u32 = 5;
pub const VFIO_IRQ_INFO_EVENTFD: u32 = 1;
pub const VFIO_IRQ_INFO_MASKABLE: u32 = 2;
pub const VFIO_IRQ_INFO_AUTOMASKED: u32 = 4;
pub const VFIO_IRQ_INFO_NORESIZE: u32 = 8;
pub const VFIO_IRQ_SET_DATA_NONE: u32 = 1;
pub const VFIO_IRQ_SET_DATA_BOOL: u32 = 2;
pub const VFIO_IRQ_SET_DATA_EVENTFD: u32 = 4;
pub const VFIO_IRQ_SET_ACTION_MASK: u32 = 8;
pub const VFIO_IRQ_SET_ACTION_UNMASK: u32 = 16;
pub const VFIO_IRQ_SET_ACTION_TRIGGER: u32 = 32;
pub const VFIO_IRQ_SET_DATA_TYPE_MASK: u32 = 7;
pub const VFIO_IRQ_SET_ACTION_TYPE_MASK: u32 = 56;
pub const VFIO_GFX_PLANE_TYPE_PROBE: u32 = 1;
pub const VFIO_GFX_PLANE_TYPE_DMABUF: u32 = 2;
pub const VFIO_GFX_PLANE_TYPE_REGION: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_8: u32 = 1;
pub const VFIO_DEVICE_IOEVENTFD_16: u32 = 2;
pub const VFIO_DEVICE_IOEVENTFD_32: u32 = 4;
pub const VFIO_DEVICE_IOEVENTFD_64: u32 = 8;
pub const VFIO_DEVICE_IOEVENTFD_SIZE_MASK: u32 = 15;
pub const VFIO_DEVICE_FEATURE_MASK: u32 = 65535;
pub const VFIO_DEVICE_FEATURE_GET: u32 = 65536;
pub const VFIO_DEVICE_FEATURE_SET: u32 = 131072;
pub const VFIO_DEVICE_FEATURE_PROBE: u32 = 262144;
pub const VFIO_DEVICE_FEATURE_PCI_VF_TOKEN: u32 = 0;
pub const VFIO_IOMMU_INFO_PGSIZES: u32 = 1;
pub const VFIO_IOMMU_INFO_CAPS: u32 = 2;
pub const VFIO_IOMMU_TYPE1_INFO_CAP_IOVA_RANGE: u32 = 1;
pub const VFIO_IOMMU_TYPE1_INFO_CAP_MIGRATION: u32 = 2;
pub const VFIO_IOMMU_TYPE1_INFO_DMA_AVAIL: u32 = 3;
pub const VFIO_DMA_MAP_FLAG_READ: u32 = 1;
pub const VFIO_DMA_MAP_FLAG_WRITE: u32 = 2;
pub const VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP: u32 = 1;
pub const VFIO_IOMMU_DIRTY_PAGES_FLAG_START: u32 = 1;
pub const VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP: u32 = 2;
pub const VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP: u32 = 4;
pub const VFIO_IOMMU_SPAPR_INFO_DDW: u32 = 1;
pub const VFIO_EEH_PE_DISABLE: u32 = 0;
pub const VFIO_EEH_PE_ENABLE: u32 = 1;
pub const VFIO_EEH_PE_UNFREEZE_IO: u32 = 2;
pub const VFIO_EEH_PE_UNFREEZE_DMA: u32 = 3;
pub const VFIO_EEH_PE_GET_STATE: u32 = 4;
pub const VFIO_EEH_PE_STATE_NORMAL: u32 = 0;
pub const VFIO_EEH_PE_STATE_RESET: u32 = 1;
pub const VFIO_EEH_PE_STATE_STOPPED: u32 = 2;
pub const VFIO_EEH_PE_STATE_STOPPED_DMA: u32 = 4;
pub const VFIO_EEH_PE_STATE_UNAVAIL: u32 = 5;
pub const VFIO_EEH_PE_RESET_DEACTIVATE: u32 = 5;
pub const VFIO_EEH_PE_RESET_HOT: u32 = 6;
pub const VFIO_EEH_PE_RESET_FUNDAMENTAL: u32 = 7;
pub const VFIO_EEH_PE_CONFIGURE: u32 = 8;
pub const VFIO_EEH_PE_INJECT_ERR: u32 = 9;
pub const LINUX_VERSION_CODE: u32 = 330496;
pub const VFIO_USER_FLAGS_NO_REPLY: u32 = 1;
pub const VFIO_USER_F_TYPE_COMMAND: u32 = 0;
pub const VFIO_USER_F_TYPE_REPLY: u32 = 1;
pub const VFIO_USER_F_DMA_REGION_MAPPABLE: u32 = 1;
pub const LIB_VFIO_USER_MAJOR: u32 = 0;
pub const LIB_VFIO_USER_MINOR: u32 = 1;
pub const VFU_DMA_REGIONS: u32 = 16;
pub const LIBVFIO_USER_FLAG_ATTACH_NB: u32 = 1;
pub const VFU_REGION_FLAG_READ: u32 = 1;
pub const VFU_REGION_FLAG_WRITE: u32 = 2;
pub const VFU_REGION_FLAG_RW: u32 = 3;
pub const VFU_REGION_FLAG_MEM: u32 = 4;
pub const VFU_MIGR_CALLBACKS_VERS: u32 = 1;
pub const VFU_CAP_FLAG_EXTENDED: u32 = 1;
pub const VFU_CAP_FLAG_CALLBACK: u32 = 2;
pub const VFU_CAP_FLAG_READONLY: u32 = 4;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: ::std::os::raw::c_int,
        __iovec: *const iovec,
        __count: ::std::os::raw::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::std::os::raw::c_char,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 0;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 2;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 3;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 5;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 6;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 7;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 8;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 9;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 10;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 11;
pub const _PC_SOCK_MAXBUF: ::std::os::raw::c_uint = 12;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 13;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 17;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 18;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 19;
pub const _PC_2_SYMLINKS: ::std::os::raw::c_uint = 20;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: ::std::os::raw::c_uint = 0;
pub const _SC_CHILD_MAX: ::std::os::raw::c_uint = 1;
pub const _SC_CLK_TCK: ::std::os::raw::c_uint = 2;
pub const _SC_NGROUPS_MAX: ::std::os::raw::c_uint = 3;
pub const _SC_OPEN_MAX: ::std::os::raw::c_uint = 4;
pub const _SC_STREAM_MAX: ::std::os::raw::c_uint = 5;
pub const _SC_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _SC_JOB_CONTROL: ::std::os::raw::c_uint = 7;
pub const _SC_SAVED_IDS: ::std::os::raw::c_uint = 8;
pub const _SC_REALTIME_SIGNALS: ::std::os::raw::c_uint = 9;
pub const _SC_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 10;
pub const _SC_TIMERS: ::std::os::raw::c_uint = 11;
pub const _SC_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 12;
pub const _SC_PRIORITIZED_IO: ::std::os::raw::c_uint = 13;
pub const _SC_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 14;
pub const _SC_FSYNC: ::std::os::raw::c_uint = 15;
pub const _SC_MAPPED_FILES: ::std::os::raw::c_uint = 16;
pub const _SC_MEMLOCK: ::std::os::raw::c_uint = 17;
pub const _SC_MEMLOCK_RANGE: ::std::os::raw::c_uint = 18;
pub const _SC_MEMORY_PROTECTION: ::std::os::raw::c_uint = 19;
pub const _SC_MESSAGE_PASSING: ::std::os::raw::c_uint = 20;
pub const _SC_SEMAPHORES: ::std::os::raw::c_uint = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 22;
pub const _SC_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 23;
pub const _SC_AIO_MAX: ::std::os::raw::c_uint = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 25;
pub const _SC_DELAYTIMER_MAX: ::std::os::raw::c_uint = 26;
pub const _SC_MQ_OPEN_MAX: ::std::os::raw::c_uint = 27;
pub const _SC_MQ_PRIO_MAX: ::std::os::raw::c_uint = 28;
pub const _SC_VERSION: ::std::os::raw::c_uint = 29;
pub const _SC_PAGESIZE: ::std::os::raw::c_uint = 30;
pub const _SC_RTSIG_MAX: ::std::os::raw::c_uint = 31;
pub const _SC_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 32;
pub const _SC_SEM_VALUE_MAX: ::std::os::raw::c_uint = 33;
pub const _SC_SIGQUEUE_MAX: ::std::os::raw::c_uint = 34;
pub const _SC_TIMER_MAX: ::std::os::raw::c_uint = 35;
pub const _SC_BC_BASE_MAX: ::std::os::raw::c_uint = 36;
pub const _SC_BC_DIM_MAX: ::std::os::raw::c_uint = 37;
pub const _SC_BC_SCALE_MAX: ::std::os::raw::c_uint = 38;
pub const _SC_BC_STRING_MAX: ::std::os::raw::c_uint = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 40;
pub const _SC_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 41;
pub const _SC_EXPR_NEST_MAX: ::std::os::raw::c_uint = 42;
pub const _SC_LINE_MAX: ::std::os::raw::c_uint = 43;
pub const _SC_RE_DUP_MAX: ::std::os::raw::c_uint = 44;
pub const _SC_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 45;
pub const _SC_2_VERSION: ::std::os::raw::c_uint = 46;
pub const _SC_2_C_BIND: ::std::os::raw::c_uint = 47;
pub const _SC_2_C_DEV: ::std::os::raw::c_uint = 48;
pub const _SC_2_FORT_DEV: ::std::os::raw::c_uint = 49;
pub const _SC_2_FORT_RUN: ::std::os::raw::c_uint = 50;
pub const _SC_2_SW_DEV: ::std::os::raw::c_uint = 51;
pub const _SC_2_LOCALEDEF: ::std::os::raw::c_uint = 52;
pub const _SC_PII: ::std::os::raw::c_uint = 53;
pub const _SC_PII_XTI: ::std::os::raw::c_uint = 54;
pub const _SC_PII_SOCKET: ::std::os::raw::c_uint = 55;
pub const _SC_PII_INTERNET: ::std::os::raw::c_uint = 56;
pub const _SC_PII_OSI: ::std::os::raw::c_uint = 57;
pub const _SC_POLL: ::std::os::raw::c_uint = 58;
pub const _SC_SELECT: ::std::os::raw::c_uint = 59;
pub const _SC_UIO_MAXIOV: ::std::os::raw::c_uint = 60;
pub const _SC_IOV_MAX: ::std::os::raw::c_uint = 60;
pub const _SC_PII_INTERNET_STREAM: ::std::os::raw::c_uint = 61;
pub const _SC_PII_INTERNET_DGRAM: ::std::os::raw::c_uint = 62;
pub const _SC_PII_OSI_COTS: ::std::os::raw::c_uint = 63;
pub const _SC_PII_OSI_CLTS: ::std::os::raw::c_uint = 64;
pub const _SC_PII_OSI_M: ::std::os::raw::c_uint = 65;
pub const _SC_T_IOV_MAX: ::std::os::raw::c_uint = 66;
pub const _SC_THREADS: ::std::os::raw::c_uint = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::std::os::raw::c_uint = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::std::os::raw::c_uint = 70;
pub const _SC_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 71;
pub const _SC_TTY_NAME_MAX: ::std::os::raw::c_uint = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 73;
pub const _SC_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 74;
pub const _SC_THREAD_STACK_MIN: ::std::os::raw::c_uint = 75;
pub const _SC_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 82;
pub const _SC_NPROCESSORS_CONF: ::std::os::raw::c_uint = 83;
pub const _SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 84;
pub const _SC_PHYS_PAGES: ::std::os::raw::c_uint = 85;
pub const _SC_AVPHYS_PAGES: ::std::os::raw::c_uint = 86;
pub const _SC_ATEXIT_MAX: ::std::os::raw::c_uint = 87;
pub const _SC_PASS_MAX: ::std::os::raw::c_uint = 88;
pub const _SC_XOPEN_VERSION: ::std::os::raw::c_uint = 89;
pub const _SC_XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 90;
pub const _SC_XOPEN_UNIX: ::std::os::raw::c_uint = 91;
pub const _SC_XOPEN_CRYPT: ::std::os::raw::c_uint = 92;
pub const _SC_XOPEN_ENH_I18N: ::std::os::raw::c_uint = 93;
pub const _SC_XOPEN_SHM: ::std::os::raw::c_uint = 94;
pub const _SC_2_CHAR_TERM: ::std::os::raw::c_uint = 95;
pub const _SC_2_C_VERSION: ::std::os::raw::c_uint = 96;
pub const _SC_2_UPE: ::std::os::raw::c_uint = 97;
pub const _SC_XOPEN_XPG2: ::std::os::raw::c_uint = 98;
pub const _SC_XOPEN_XPG3: ::std::os::raw::c_uint = 99;
pub const _SC_XOPEN_XPG4: ::std::os::raw::c_uint = 100;
pub const _SC_CHAR_BIT: ::std::os::raw::c_uint = 101;
pub const _SC_CHAR_MAX: ::std::os::raw::c_uint = 102;
pub const _SC_CHAR_MIN: ::std::os::raw::c_uint = 103;
pub const _SC_INT_MAX: ::std::os::raw::c_uint = 104;
pub const _SC_INT_MIN: ::std::os::raw::c_uint = 105;
pub const _SC_LONG_BIT: ::std::os::raw::c_uint = 106;
pub const _SC_WORD_BIT: ::std::os::raw::c_uint = 107;
pub const _SC_MB_LEN_MAX: ::std::os::raw::c_uint = 108;
pub const _SC_NZERO: ::std::os::raw::c_uint = 109;
pub const _SC_SSIZE_MAX: ::std::os::raw::c_uint = 110;
pub const _SC_SCHAR_MAX: ::std::os::raw::c_uint = 111;
pub const _SC_SCHAR_MIN: ::std::os::raw::c_uint = 112;
pub const _SC_SHRT_MAX: ::std::os::raw::c_uint = 113;
pub const _SC_SHRT_MIN: ::std::os::raw::c_uint = 114;
pub const _SC_UCHAR_MAX: ::std::os::raw::c_uint = 115;
pub const _SC_UINT_MAX: ::std::os::raw::c_uint = 116;
pub const _SC_ULONG_MAX: ::std::os::raw::c_uint = 117;
pub const _SC_USHRT_MAX: ::std::os::raw::c_uint = 118;
pub const _SC_NL_ARGMAX: ::std::os::raw::c_uint = 119;
pub const _SC_NL_LANGMAX: ::std::os::raw::c_uint = 120;
pub const _SC_NL_MSGMAX: ::std::os::raw::c_uint = 121;
pub const _SC_NL_NMAX: ::std::os::raw::c_uint = 122;
pub const _SC_NL_SETMAX: ::std::os::raw::c_uint = 123;
pub const _SC_NL_TEXTMAX: ::std::os::raw::c_uint = 124;
pub const _SC_XBS5_ILP32_OFF32: ::std::os::raw::c_uint = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 126;
pub const _SC_XBS5_LP64_OFF64: ::std::os::raw::c_uint = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 128;
pub const _SC_XOPEN_LEGACY: ::std::os::raw::c_uint = 129;
pub const _SC_XOPEN_REALTIME: ::std::os::raw::c_uint = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 131;
pub const _SC_ADVISORY_INFO: ::std::os::raw::c_uint = 132;
pub const _SC_BARRIERS: ::std::os::raw::c_uint = 133;
pub const _SC_BASE: ::std::os::raw::c_uint = 134;
pub const _SC_C_LANG_SUPPORT: ::std::os::raw::c_uint = 135;
pub const _SC_C_LANG_SUPPORT_R: ::std::os::raw::c_uint = 136;
pub const _SC_CLOCK_SELECTION: ::std::os::raw::c_uint = 137;
pub const _SC_CPUTIME: ::std::os::raw::c_uint = 138;
pub const _SC_THREAD_CPUTIME: ::std::os::raw::c_uint = 139;
pub const _SC_DEVICE_IO: ::std::os::raw::c_uint = 140;
pub const _SC_DEVICE_SPECIFIC: ::std::os::raw::c_uint = 141;
pub const _SC_DEVICE_SPECIFIC_R: ::std::os::raw::c_uint = 142;
pub const _SC_FD_MGMT: ::std::os::raw::c_uint = 143;
pub const _SC_FIFO: ::std::os::raw::c_uint = 144;
pub const _SC_PIPE: ::std::os::raw::c_uint = 145;
pub const _SC_FILE_ATTRIBUTES: ::std::os::raw::c_uint = 146;
pub const _SC_FILE_LOCKING: ::std::os::raw::c_uint = 147;
pub const _SC_FILE_SYSTEM: ::std::os::raw::c_uint = 148;
pub const _SC_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 149;
pub const _SC_MULTI_PROCESS: ::std::os::raw::c_uint = 150;
pub const _SC_SINGLE_PROCESS: ::std::os::raw::c_uint = 151;
pub const _SC_NETWORKING: ::std::os::raw::c_uint = 152;
pub const _SC_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 153;
pub const _SC_SPIN_LOCKS: ::std::os::raw::c_uint = 154;
pub const _SC_REGEXP: ::std::os::raw::c_uint = 155;
pub const _SC_REGEX_VERSION: ::std::os::raw::c_uint = 156;
pub const _SC_SHELL: ::std::os::raw::c_uint = 157;
pub const _SC_SIGNALS: ::std::os::raw::c_uint = 158;
pub const _SC_SPAWN: ::std::os::raw::c_uint = 159;
pub const _SC_SPORADIC_SERVER: ::std::os::raw::c_uint = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::std::os::raw::c_uint = 161;
pub const _SC_SYSTEM_DATABASE: ::std::os::raw::c_uint = 162;
pub const _SC_SYSTEM_DATABASE_R: ::std::os::raw::c_uint = 163;
pub const _SC_TIMEOUTS: ::std::os::raw::c_uint = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 165;
pub const _SC_USER_GROUPS: ::std::os::raw::c_uint = 166;
pub const _SC_USER_GROUPS_R: ::std::os::raw::c_uint = 167;
pub const _SC_2_PBS: ::std::os::raw::c_uint = 168;
pub const _SC_2_PBS_ACCOUNTING: ::std::os::raw::c_uint = 169;
pub const _SC_2_PBS_LOCATE: ::std::os::raw::c_uint = 170;
pub const _SC_2_PBS_MESSAGE: ::std::os::raw::c_uint = 171;
pub const _SC_2_PBS_TRACK: ::std::os::raw::c_uint = 172;
pub const _SC_SYMLOOP_MAX: ::std::os::raw::c_uint = 173;
pub const _SC_STREAMS: ::std::os::raw::c_uint = 174;
pub const _SC_2_PBS_CHECKPOINT: ::std::os::raw::c_uint = 175;
pub const _SC_V6_ILP32_OFF32: ::std::os::raw::c_uint = 176;
pub const _SC_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 177;
pub const _SC_V6_LP64_OFF64: ::std::os::raw::c_uint = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 179;
pub const _SC_HOST_NAME_MAX: ::std::os::raw::c_uint = 180;
pub const _SC_TRACE: ::std::os::raw::c_uint = 181;
pub const _SC_TRACE_EVENT_FILTER: ::std::os::raw::c_uint = 182;
pub const _SC_TRACE_INHERIT: ::std::os::raw::c_uint = 183;
pub const _SC_TRACE_LOG: ::std::os::raw::c_uint = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: ::std::os::raw::c_uint = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: ::std::os::raw::c_uint = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: ::std::os::raw::c_uint = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: ::std::os::raw::c_uint = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: ::std::os::raw::c_uint = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: ::std::os::raw::c_uint = 190;
pub const _SC_LEVEL2_CACHE_SIZE: ::std::os::raw::c_uint = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: ::std::os::raw::c_uint = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: ::std::os::raw::c_uint = 193;
pub const _SC_LEVEL3_CACHE_SIZE: ::std::os::raw::c_uint = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: ::std::os::raw::c_uint = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: ::std::os::raw::c_uint = 196;
pub const _SC_LEVEL4_CACHE_SIZE: ::std::os::raw::c_uint = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: ::std::os::raw::c_uint = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: ::std::os::raw::c_uint = 199;
pub const _SC_IPV6: ::std::os::raw::c_uint = 235;
pub const _SC_RAW_SOCKETS: ::std::os::raw::c_uint = 236;
pub const _SC_V7_ILP32_OFF32: ::std::os::raw::c_uint = 237;
pub const _SC_V7_ILP32_OFFBIG: ::std::os::raw::c_uint = 238;
pub const _SC_V7_LP64_OFF64: ::std::os::raw::c_uint = 239;
pub const _SC_V7_LPBIG_OFFBIG: ::std::os::raw::c_uint = 240;
pub const _SC_SS_REPL_MAX: ::std::os::raw::c_uint = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 242;
pub const _SC_TRACE_NAME_MAX: ::std::os::raw::c_uint = 243;
pub const _SC_TRACE_SYS_MAX: ::std::os::raw::c_uint = 244;
pub const _SC_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 245;
pub const _SC_XOPEN_STREAMS: ::std::os::raw::c_uint = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_uint = 248;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _CS_PATH: ::std::os::raw::c_uint = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 1;
pub const _CS_GNU_LIBC_VERSION: ::std::os::raw::c_uint = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::std::os::raw::c_uint = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 5;
pub const _CS_LFS_CFLAGS: ::std::os::raw::c_uint = 1000;
pub const _CS_LFS_LDFLAGS: ::std::os::raw::c_uint = 1001;
pub const _CS_LFS_LIBS: ::std::os::raw::c_uint = 1002;
pub const _CS_LFS_LINTFLAGS: ::std::os::raw::c_uint = 1003;
pub const _CS_LFS64_CFLAGS: ::std::os::raw::c_uint = 1004;
pub const _CS_LFS64_LDFLAGS: ::std::os::raw::c_uint = 1005;
pub const _CS_LFS64_LIBS: ::std::os::raw::c_uint = 1006;
pub const _CS_LFS64_LINTFLAGS: ::std::os::raw::c_uint = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1147;
pub const _CS_V6_ENV: ::std::os::raw::c_uint = 1148;
pub const _CS_V7_ENV: ::std::os::raw::c_uint = 1149;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: size_t,
        __offset: size_t,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn closelog();
}
extern "C" {
    pub fn openlog(
        __ident: *const ::std::os::raw::c_char,
        __option: ::std::os::raw::c_int,
        __facility: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlogmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syslog(__pri: ::std::os::raw::c_int, __fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vsyslog(
        __pri: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __ap: *mut __va_list_tag,
    );
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cap_hdr {
    pub id: u8,
    pub next: u8,
}
#[test]
fn bindgen_test_layout_cap_hdr() {
    assert_eq!(
        ::std::mem::size_of::<cap_hdr>(),
        2usize,
        concat!("Size of: ", stringify!(cap_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cap_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(cap_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cap_hdr>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cap_hdr),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cap_hdr>())).next as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cap_hdr),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct vsc {
    pub hdr: cap_hdr,
    pub size: u8,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_vsc() {
    assert_eq!(
        ::std::mem::size_of::<vsc>(),
        3usize,
        concat!("Size of: ", stringify!(vsc))
    );
    assert_eq!(
        ::std::mem::align_of::<vsc>(),
        1usize,
        concat!("Alignment of ", stringify!(vsc))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pcie_ext_cap_hdr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pcie_ext_cap_hdr() {
    assert_eq!(
        ::std::mem::size_of::<pcie_ext_cap_hdr>(),
        4usize,
        concat!("Size of: ", stringify!(pcie_ext_cap_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_ext_cap_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(pcie_ext_cap_hdr))
    );
}
impl pcie_ext_cap_hdr {
    #[inline]
    pub fn id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn next(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_next(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        id: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
        next: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let next: u32 = unsafe { ::std::mem::transmute(next) };
            next as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct pcie_ext_cap_vsc_hdr {
    pub hdr: pcie_ext_cap_hdr,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_pcie_ext_cap_vsc_hdr() {
    assert_eq!(
        ::std::mem::size_of::<pcie_ext_cap_vsc_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(pcie_ext_cap_vsc_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<pcie_ext_cap_vsc_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(pcie_ext_cap_vsc_hdr))
    );
}
impl pcie_ext_cap_vsc_hdr {
    #[inline]
    pub fn id(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_id(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn rev(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rev(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn len(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_len(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        id: ::std::os::raw::c_uint,
        rev: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let id: u32 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let rev: u32 = unsafe { ::std::mem::transmute(rev) };
            rev as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let len: u32 = unsafe { ::std::mem::transmute(len) };
            len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct dsncap {
    pub hdr: pcie_ext_cap_hdr,
    pub sn_lo: u32,
    pub sn_hi: u32,
}
#[test]
fn bindgen_test_layout_dsncap() {
    assert_eq!(
        ::std::mem::size_of::<dsncap>(),
        12usize,
        concat!("Size of: ", stringify!(dsncap))
    );
    assert_eq!(
        ::std::mem::align_of::<dsncap>(),
        1usize,
        concat!("Alignment of ", stringify!(dsncap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsncap>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dsncap),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsncap>())).sn_lo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dsncap),
            "::",
            stringify!(sn_lo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dsncap>())).sn_hi as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dsncap),
            "::",
            stringify!(sn_hi)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_mc() {
    assert_eq!(
        ::std::mem::size_of::<mc>(),
        2usize,
        concat!("Size of: ", stringify!(mc))
    );
    assert_eq!(
        ::std::mem::align_of::<mc>(),
        1usize,
        concat!("Alignment of ", stringify!(mc))
    );
}
impl mc {
    #[inline]
    pub fn msie(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_msie(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mmc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mmc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mme(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mme(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn c64(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_c64(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pvm(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pvm(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msie: ::std::os::raw::c_uint,
        mmc: ::std::os::raw::c_uint,
        mme: ::std::os::raw::c_uint,
        c64: ::std::os::raw::c_uint,
        pvm: ::std::os::raw::c_uint,
        res1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msie: u32 = unsafe { ::std::mem::transmute(msie) };
            msie as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let mmc: u32 = unsafe { ::std::mem::transmute(mmc) };
            mmc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let mme: u32 = unsafe { ::std::mem::transmute(mme) };
            mme as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let c64: u32 = unsafe { ::std::mem::transmute(c64) };
            c64 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pvm: u32 = unsafe { ::std::mem::transmute(pvm) };
            pvm as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ma {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ma() {
    assert_eq!(
        ::std::mem::size_of::<ma>(),
        4usize,
        concat!("Size of: ", stringify!(ma))
    );
    assert_eq!(
        ::std::mem::align_of::<ma>(),
        1usize,
        concat!("Alignment of ", stringify!(ma))
    );
}
impl ma {
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn addr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: ::std::os::raw::c_uint,
        addr: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let addr: u32 = unsafe { ::std::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct msicap {
    pub hdr: cap_hdr,
    pub mc: mc,
    pub ma: ma,
    pub mua: u32,
    pub md: u16,
    pub padding: u16,
    pub mmask: u32,
    pub mpend: u32,
}
#[test]
fn bindgen_test_layout_msicap() {
    assert_eq!(
        ::std::mem::size_of::<msicap>(),
        24usize,
        concat!("Size of: ", stringify!(msicap))
    );
    assert_eq!(
        ::std::mem::align_of::<msicap>(),
        1usize,
        concat!("Alignment of ", stringify!(msicap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).mc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(mc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).ma as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(ma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).mua as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(mua)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).md as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(md)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).padding as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).mmask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(mmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msicap>())).mpend as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(msicap),
            "::",
            stringify!(mpend)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mxc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_mxc() {
    assert_eq!(
        ::std::mem::size_of::<mxc>(),
        2usize,
        concat!("Size of: ", stringify!(mxc))
    );
    assert_eq!(
        ::std::mem::align_of::<mxc>(),
        1usize,
        concat!("Alignment of ", stringify!(mxc))
    );
}
impl mxc {
    #[inline]
    pub fn ts(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_ts(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fm(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fm(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mxe(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mxe(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ts: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
        fm: ::std::os::raw::c_uint,
        mxe: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let ts: u32 = unsafe { ::std::mem::transmute(ts) };
            ts as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let fm: u32 = unsafe { ::std::mem::transmute(fm) };
            fm as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let mxe: u32 = unsafe { ::std::mem::transmute(mxe) };
            mxe as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mtab {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mtab() {
    assert_eq!(
        ::std::mem::size_of::<mtab>(),
        4usize,
        concat!("Size of: ", stringify!(mtab))
    );
    assert_eq!(
        ::std::mem::align_of::<mtab>(),
        1usize,
        concat!("Alignment of ", stringify!(mtab))
    );
}
impl mtab {
    #[inline]
    pub fn tbir(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tbir(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn to(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_to(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tbir: ::std::os::raw::c_uint,
        to: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let tbir: u32 = unsafe { ::std::mem::transmute(tbir) };
            tbir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let to: u32 = unsafe { ::std::mem::transmute(to) };
            to as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mpba {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_mpba() {
    assert_eq!(
        ::std::mem::size_of::<mpba>(),
        4usize,
        concat!("Size of: ", stringify!(mpba))
    );
    assert_eq!(
        ::std::mem::align_of::<mpba>(),
        1usize,
        concat!("Alignment of ", stringify!(mpba))
    );
}
impl mpba {
    #[inline]
    pub fn pbir(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pbir(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pbao(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_pbao(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pbir: ::std::os::raw::c_uint,
        pbao: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pbir: u32 = unsafe { ::std::mem::transmute(pbir) };
            pbir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let pbao: u32 = unsafe { ::std::mem::transmute(pbao) };
            pbao as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct msixcap {
    pub hdr: cap_hdr,
    pub mxc: mxc,
    pub mtab: mtab,
    pub mpba: mpba,
}
#[test]
fn bindgen_test_layout_msixcap() {
    assert_eq!(
        ::std::mem::size_of::<msixcap>(),
        12usize,
        concat!("Size of: ", stringify!(msixcap))
    );
    assert_eq!(
        ::std::mem::align_of::<msixcap>(),
        4usize,
        concat!("Alignment of ", stringify!(msixcap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msixcap>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msixcap),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msixcap>())).mxc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(msixcap),
            "::",
            stringify!(mxc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msixcap>())).mtab as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msixcap),
            "::",
            stringify!(mtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msixcap>())).mpba as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msixcap),
            "::",
            stringify!(mpba)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pc() {
    assert_eq!(
        ::std::mem::size_of::<pc>(),
        2usize,
        concat!("Size of: ", stringify!(pc))
    );
    assert_eq!(
        ::std::mem::align_of::<pc>(),
        1usize,
        concat!("Alignment of ", stringify!(pc))
    );
}
impl pc {
    #[inline]
    pub fn vs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pmec(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pmec(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsi(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsi(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auxc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_auxc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn d1s(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_d1s(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn d2s(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_d2s(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_psup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vs: ::std::os::raw::c_uint,
        pmec: ::std::os::raw::c_uint,
        res: ::std::os::raw::c_uint,
        dsi: ::std::os::raw::c_uint,
        auxc: ::std::os::raw::c_uint,
        d1s: ::std::os::raw::c_uint,
        d2s: ::std::os::raw::c_uint,
        psup: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let vs: u32 = unsafe { ::std::mem::transmute(vs) };
            vs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let pmec: u32 = unsafe { ::std::mem::transmute(pmec) };
            pmec as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsi: u32 = unsafe { ::std::mem::transmute(dsi) };
            dsi as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let auxc: u32 = unsafe { ::std::mem::transmute(auxc) };
            auxc as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let d1s: u32 = unsafe { ::std::mem::transmute(d1s) };
            d1s as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let d2s: u32 = unsafe { ::std::mem::transmute(d2s) };
            d2s as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let psup: u32 = unsafe { ::std::mem::transmute(psup) };
            psup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pmcs {
    pub __bindgen_anon_1: pmcs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmcs__bindgen_ty_1 {
    pub raw: u16,
    pub __bindgen_anon_1: pmcs__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
//#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct pmcs__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_pmcs__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pmcs__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(pmcs__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pmcs__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pmcs__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl pmcs__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ps(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ps(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nsfrst(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nsfrst(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pmee(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pmee(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dse(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dse(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dsc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dsc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pmes(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pmes(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ps: ::std::os::raw::c_uint,
        res1: ::std::os::raw::c_uint,
        nsfrst: ::std::os::raw::c_uint,
        res2: ::std::os::raw::c_uint,
        pmee: ::std::os::raw::c_uint,
        dse: ::std::os::raw::c_uint,
        dsc: ::std::os::raw::c_uint,
        pmes: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let ps: u32 = unsafe { ::std::mem::transmute(ps) };
            ps as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nsfrst: u32 = unsafe { ::std::mem::transmute(nsfrst) };
            nsfrst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pmee: u32 = unsafe { ::std::mem::transmute(pmee) };
            pmee as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let dse: u32 = unsafe { ::std::mem::transmute(dse) };
            dse as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let dsc: u32 = unsafe { ::std::mem::transmute(dsc) };
            dsc as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pmes: u32 = unsafe { ::std::mem::transmute(pmes) };
            pmes as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pmcs__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pmcs__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(pmcs__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pmcs__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pmcs__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmcs__bindgen_ty_1>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmcs__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_pmcs() {
    assert_eq!(
        ::std::mem::size_of::<pmcs>(),
        4usize,
        concat!("Size of: ", stringify!(pmcs))
    );
    assert_eq!(
        ::std::mem::align_of::<pmcs>(),
        1usize,
        concat!("Alignment of ", stringify!(pmcs))
    );
}
#[repr(C, packed(8))]
#[derive(Copy, Clone)]
pub struct pmcap {
    pub hdr: cap_hdr,
    pub pc: pc,
    pub pmcs: pmcs,
}
#[test]
fn bindgen_test_layout_pmcap() {
    assert_eq!(
        ::std::mem::size_of::<pmcap>(),
        8usize,
        concat!("Size of: ", stringify!(pmcap))
    );
    assert_eq!(
        ::std::mem::align_of::<pmcap>(),
        8usize,
        concat!("Alignment of ", stringify!(pmcap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmcap>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pmcap),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmcap>())).pc as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(pmcap), "::", stringify!(pc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pmcap>())).pmcs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pmcap),
            "::",
            stringify!(pmcs)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxcaps {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxcaps() {
    assert_eq!(
        ::std::mem::size_of::<pxcaps>(),
        2usize,
        concat!("Size of: ", stringify!(pxcaps))
    );
    assert_eq!(
        ::std::mem::align_of::<pxcaps>(),
        1usize,
        concat!("Alignment of ", stringify!(pxcaps))
    );
}
impl pxcaps {
    #[inline]
    pub fn ver(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ver(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dpt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dpt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn si(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_si(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn imn(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_imn(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ver: ::std::os::raw::c_uint,
        dpt: ::std::os::raw::c_uint,
        si: ::std::os::raw::c_uint,
        imn: ::std::os::raw::c_uint,
        res1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ver: u32 = unsafe { ::std::mem::transmute(ver) };
            ver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let dpt: u32 = unsafe { ::std::mem::transmute(dpt) };
            dpt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let si: u32 = unsafe { ::std::mem::transmute(si) };
            si as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let imn: u32 = unsafe { ::std::mem::transmute(imn) };
            imn as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxdcap {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxdcap() {
    assert_eq!(
        ::std::mem::size_of::<pxdcap>(),
        4usize,
        concat!("Size of: ", stringify!(pxdcap))
    );
    assert_eq!(
        ::std::mem::align_of::<pxdcap>(),
        1usize,
        concat!("Alignment of ", stringify!(pxdcap))
    );
}
impl pxdcap {
    #[inline]
    pub fn mps(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pfs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pfs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn etfs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_etfs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l0sl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_l0sl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn l1l(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_l1l(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn per(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_per(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn csplv(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_csplv(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cspls(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cspls(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn flrc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flrc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mps: ::std::os::raw::c_uint,
        pfs: ::std::os::raw::c_uint,
        etfs: ::std::os::raw::c_uint,
        l0sl: ::std::os::raw::c_uint,
        l1l: ::std::os::raw::c_uint,
        per: ::std::os::raw::c_uint,
        res1: ::std::os::raw::c_uint,
        csplv: ::std::os::raw::c_uint,
        cspls: ::std::os::raw::c_uint,
        flrc: ::std::os::raw::c_uint,
        res2: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let mps: u32 = unsafe { ::std::mem::transmute(mps) };
            mps as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let pfs: u32 = unsafe { ::std::mem::transmute(pfs) };
            pfs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let etfs: u32 = unsafe { ::std::mem::transmute(etfs) };
            etfs as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let l0sl: u32 = unsafe { ::std::mem::transmute(l0sl) };
            l0sl as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let l1l: u32 = unsafe { ::std::mem::transmute(l1l) };
            l1l as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let per: u32 = unsafe { ::std::mem::transmute(per) };
            per as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 8u8, {
            let csplv: u32 = unsafe { ::std::mem::transmute(csplv) };
            csplv as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let cspls: u32 = unsafe { ::std::mem::transmute(cspls) };
            cspls as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let flrc: u32 = unsafe { ::std::mem::transmute(flrc) };
            flrc as u64
        });
        __bindgen_bitfield_unit.set(26usize, 3u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union pxdc {
    pub raw: u16,
    pub __bindgen_anon_1: pxdc__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxdc__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxdc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pxdc__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(pxdc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pxdc__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(pxdc__bindgen_ty_1))
    );
}
impl pxdc__bindgen_ty_1 {
    #[inline]
    pub fn cere(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cere(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nfere(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nfere(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fere(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fere(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urre(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_urre(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ero(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ero(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mps(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ete(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ete(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfe(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pfe(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn appme(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appme(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ens(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ens(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mrrs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mrrs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn iflr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iflr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cere: ::std::os::raw::c_uint,
        nfere: ::std::os::raw::c_uint,
        fere: ::std::os::raw::c_uint,
        urre: ::std::os::raw::c_uint,
        ero: ::std::os::raw::c_uint,
        mps: ::std::os::raw::c_uint,
        ete: ::std::os::raw::c_uint,
        pfe: ::std::os::raw::c_uint,
        appme: ::std::os::raw::c_uint,
        ens: ::std::os::raw::c_uint,
        mrrs: ::std::os::raw::c_uint,
        iflr: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cere: u32 = unsafe { ::std::mem::transmute(cere) };
            cere as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nfere: u32 = unsafe { ::std::mem::transmute(nfere) };
            nfere as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let fere: u32 = unsafe { ::std::mem::transmute(fere) };
            fere as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let urre: u32 = unsafe { ::std::mem::transmute(urre) };
            urre as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ero: u32 = unsafe { ::std::mem::transmute(ero) };
            ero as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mps: u32 = unsafe { ::std::mem::transmute(mps) };
            mps as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ete: u32 = unsafe { ::std::mem::transmute(ete) };
            ete as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let pfe: u32 = unsafe { ::std::mem::transmute(pfe) };
            pfe as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let appme: u32 = unsafe { ::std::mem::transmute(appme) };
            appme as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ens: u32 = unsafe { ::std::mem::transmute(ens) };
            ens as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let mrrs: u32 = unsafe { ::std::mem::transmute(mrrs) };
            mrrs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let iflr: u32 = unsafe { ::std::mem::transmute(iflr) };
            iflr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_pxdc() {
    assert_eq!(
        ::std::mem::size_of::<pxdc>(),
        2usize,
        concat!("Size of: ", stringify!(pxdc))
    );
    assert_eq!(
        ::std::mem::align_of::<pxdc>(),
        1usize,
        concat!("Alignment of ", stringify!(pxdc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxdc>())).raw as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(pxdc), "::", stringify!(raw))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxds {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxds() {
    assert_eq!(
        ::std::mem::size_of::<pxds>(),
        2usize,
        concat!("Size of: ", stringify!(pxds))
    );
    assert_eq!(
        ::std::mem::align_of::<pxds>(),
        1usize,
        concat!("Alignment of ", stringify!(pxds))
    );
}
impl pxds {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxlcap {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxlcap() {
    assert_eq!(
        ::std::mem::size_of::<pxlcap>(),
        4usize,
        concat!("Size of: ", stringify!(pxlcap))
    );
    assert_eq!(
        ::std::mem::align_of::<pxlcap>(),
        1usize,
        concat!("Alignment of ", stringify!(pxlcap))
    );
}
impl pxlcap {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxlc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxlc() {
    assert_eq!(
        ::std::mem::size_of::<pxlc>(),
        2usize,
        concat!("Size of: ", stringify!(pxlc))
    );
    assert_eq!(
        ::std::mem::align_of::<pxlc>(),
        1usize,
        concat!("Alignment of ", stringify!(pxlc))
    );
}
impl pxlc {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxls {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxls() {
    assert_eq!(
        ::std::mem::size_of::<pxls>(),
        2usize,
        concat!("Size of: ", stringify!(pxls))
    );
    assert_eq!(
        ::std::mem::align_of::<pxls>(),
        1usize,
        concat!("Alignment of ", stringify!(pxls))
    );
}
impl pxls {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxscap {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxscap() {
    assert_eq!(
        ::std::mem::size_of::<pxscap>(),
        4usize,
        concat!("Size of: ", stringify!(pxscap))
    );
    assert_eq!(
        ::std::mem::align_of::<pxscap>(),
        1usize,
        concat!("Alignment of ", stringify!(pxscap))
    );
}
impl pxscap {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxsc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxsc() {
    assert_eq!(
        ::std::mem::size_of::<pxsc>(),
        2usize,
        concat!("Size of: ", stringify!(pxsc))
    );
    assert_eq!(
        ::std::mem::align_of::<pxsc>(),
        1usize,
        concat!("Alignment of ", stringify!(pxsc))
    );
}
impl pxsc {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxss {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxss() {
    assert_eq!(
        ::std::mem::size_of::<pxss>(),
        2usize,
        concat!("Size of: ", stringify!(pxss))
    );
    assert_eq!(
        ::std::mem::align_of::<pxss>(),
        1usize,
        concat!("Alignment of ", stringify!(pxss))
    );
}
impl pxss {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxrc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxrc() {
    assert_eq!(
        ::std::mem::size_of::<pxrc>(),
        2usize,
        concat!("Size of: ", stringify!(pxrc))
    );
    assert_eq!(
        ::std::mem::align_of::<pxrc>(),
        1usize,
        concat!("Alignment of ", stringify!(pxrc))
    );
}
impl pxrc {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxrcap {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxrcap() {
    assert_eq!(
        ::std::mem::size_of::<pxrcap>(),
        2usize,
        concat!("Size of: ", stringify!(pxrcap))
    );
    assert_eq!(
        ::std::mem::align_of::<pxrcap>(),
        1usize,
        concat!("Alignment of ", stringify!(pxrcap))
    );
}
impl pxrcap {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxrs {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxrs() {
    assert_eq!(
        ::std::mem::size_of::<pxrs>(),
        4usize,
        concat!("Size of: ", stringify!(pxrs))
    );
    assert_eq!(
        ::std::mem::align_of::<pxrs>(),
        1usize,
        concat!("Alignment of ", stringify!(pxrs))
    );
}
impl pxrs {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxdcap2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxdcap2() {
    assert_eq!(
        ::std::mem::size_of::<pxdcap2>(),
        4usize,
        concat!("Size of: ", stringify!(pxdcap2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxdcap2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxdcap2))
    );
}
impl pxdcap2 {
    #[inline]
    pub fn ctrs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ctrs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ctds(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctds(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn arifs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arifs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aors(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aors(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aocs32(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aocs32(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aocs64(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aocs64(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccs128(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ccs128(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nprpr(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nprpr(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ltrs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ltrs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tphcs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_tphcs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn obffs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_obffs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn effs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_effs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eetps(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eetps(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn meetp(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_meetp(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ctrs: ::std::os::raw::c_uint,
        ctds: ::std::os::raw::c_uint,
        arifs: ::std::os::raw::c_uint,
        aors: ::std::os::raw::c_uint,
        aocs32: ::std::os::raw::c_uint,
        aocs64: ::std::os::raw::c_uint,
        ccs128: ::std::os::raw::c_uint,
        nprpr: ::std::os::raw::c_uint,
        ltrs: ::std::os::raw::c_uint,
        tphcs: ::std::os::raw::c_uint,
        obffs: ::std::os::raw::c_uint,
        effs: ::std::os::raw::c_uint,
        eetps: ::std::os::raw::c_uint,
        meetp: ::std::os::raw::c_uint,
        res1: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ctrs: u32 = unsafe { ::std::mem::transmute(ctrs) };
            ctrs as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ctds: u32 = unsafe { ::std::mem::transmute(ctds) };
            ctds as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let arifs: u32 = unsafe { ::std::mem::transmute(arifs) };
            arifs as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let aors: u32 = unsafe { ::std::mem::transmute(aors) };
            aors as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let aocs32: u32 = unsafe { ::std::mem::transmute(aocs32) };
            aocs32 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let aocs64: u32 = unsafe { ::std::mem::transmute(aocs64) };
            aocs64 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ccs128: u32 = unsafe { ::std::mem::transmute(ccs128) };
            ccs128 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let nprpr: u32 = unsafe { ::std::mem::transmute(nprpr) };
            nprpr as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ltrs: u32 = unsafe { ::std::mem::transmute(ltrs) };
            ltrs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let tphcs: u32 = unsafe { ::std::mem::transmute(tphcs) };
            tphcs as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let obffs: u32 = unsafe { ::std::mem::transmute(obffs) };
            obffs as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let effs: u32 = unsafe { ::std::mem::transmute(effs) };
            effs as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let eetps: u32 = unsafe { ::std::mem::transmute(eetps) };
            eetps as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let meetp: u32 = unsafe { ::std::mem::transmute(meetp) };
            meetp as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxdc2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxdc2() {
    assert_eq!(
        ::std::mem::size_of::<pxdc2>(),
        2usize,
        concat!("Size of: ", stringify!(pxdc2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxdc2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxdc2))
    );
}
impl pxdc2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxds2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxds2() {
    assert_eq!(
        ::std::mem::size_of::<pxds2>(),
        2usize,
        concat!("Size of: ", stringify!(pxds2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxds2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxds2))
    );
}
impl pxds2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxlcap2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxlcap2() {
    assert_eq!(
        ::std::mem::size_of::<pxlcap2>(),
        4usize,
        concat!("Size of: ", stringify!(pxlcap2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxlcap2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxlcap2))
    );
}
impl pxlcap2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxlc2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxlc2() {
    assert_eq!(
        ::std::mem::size_of::<pxlc2>(),
        2usize,
        concat!("Size of: ", stringify!(pxlc2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxlc2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxlc2))
    );
}
impl pxlc2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxls2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxls2() {
    assert_eq!(
        ::std::mem::size_of::<pxls2>(),
        2usize,
        concat!("Size of: ", stringify!(pxls2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxls2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxls2))
    );
}
impl pxls2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxscap2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_pxscap2() {
    assert_eq!(
        ::std::mem::size_of::<pxscap2>(),
        4usize,
        concat!("Size of: ", stringify!(pxscap2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxscap2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxscap2))
    );
}
impl pxscap2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxsc2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxsc2() {
    assert_eq!(
        ::std::mem::size_of::<pxsc2>(),
        2usize,
        concat!("Size of: ", stringify!(pxsc2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxsc2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxsc2))
    );
}
impl pxsc2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pxss2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_pxss2() {
    assert_eq!(
        ::std::mem::size_of::<pxss2>(),
        2usize,
        concat!("Size of: ", stringify!(pxss2))
    );
    assert_eq!(
        ::std::mem::align_of::<pxss2>(),
        1usize,
        concat!("Alignment of ", stringify!(pxss2))
    );
}
impl pxss2 {
    #[inline]
    pub fn stuff(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_stuff(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(stuff: ::std::os::raw::c_uint) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let stuff: u32 = unsafe { ::std::mem::transmute(stuff) };
            stuff as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct pxcap {
    pub hdr: cap_hdr,
    pub pxcaps: pxcaps,
    pub pxdcap: pxdcap,
    pub pxdc: pxdc,
    pub pxds: pxds,
    pub pxlcap: pxlcap,
    pub pxlc: pxlc,
    pub pxls: pxls,
    pub pxscap: pxscap,
    pub pxsc: pxsc,
    pub pxss: pxss,
    pub pxrc: pxrc,
    pub pxrcap: pxrcap,
    pub pxrs: pxrs,
    pub pxdcap2: pxdcap2,
    pub pxdc2: pxdc2,
    pub pxds2: pxds2,
    pub pxlcap2: pxlcap2,
    pub pxlc2: pxlc2,
    pub pxls2: pxls2,
    pub pxscap2: pxscap2,
    pub pxsc2: pxsc2,
    pub pxss2: pxss2,
}
#[test]
fn bindgen_test_layout_pxcap() {
    assert_eq!(
        ::std::mem::size_of::<pxcap>(),
        60usize,
        concat!("Size of: ", stringify!(pxcap))
    );
    assert_eq!(
        ::std::mem::align_of::<pxcap>(),
        1usize,
        concat!("Alignment of ", stringify!(pxcap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxcaps as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxcaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxdcap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxdcap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxdc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxdc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxds as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxlcap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxlcap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxlc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxlc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxls as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxscap as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxscap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxsc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxss as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxrc as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxrcap as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxrcap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxrs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxdcap2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxdcap2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxdc2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxdc2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxds2 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxds2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxlcap2 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxlcap2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxlc2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxlc2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxls2 as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxls2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxscap2 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxscap2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxsc2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxsc2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pxcap>())).pxss2 as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(pxcap),
            "::",
            stringify!(pxss2)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_ss_t {
    pub raw: u32,
    pub __bindgen_anon_1: vfu_pci_hdr_ss_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_pci_hdr_ss_t__bindgen_ty_1 {
    pub vid: u16,
    pub sid: u16,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_ss_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_ss_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_ss_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_ss_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_ss_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_ss_t__bindgen_ty_1>())).vid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_ss_t__bindgen_ty_1),
            "::",
            stringify!(vid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_ss_t__bindgen_ty_1>())).sid as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_ss_t__bindgen_ty_1),
            "::",
            stringify!(sid)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_ss_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_ss_t>(),
        4usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_ss_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_ss_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_ss_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_ss_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_ss_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_bist_t {
    pub raw: u8,
    _bindgen_union_align: u8,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_bist_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_bist_t>(),
        1usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_bist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_bist_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_bist_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_bist_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_bist_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_bar_t {
    pub raw: u32,
    pub __bindgen_anon_1: vfu_bar_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_bar_t__bindgen_ty_1 {
    pub mem: vfu_bar_t__bindgen_ty_1__bindgen_ty_1,
    pub io: vfu_bar_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_bar_t__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_vfu_bar_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_bar_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(vfu_bar_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_bar_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(vfu_bar_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl vfu_bar_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn region_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_region_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn locatable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_locatable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn prefetchable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prefetchable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base_address(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_base_address(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        region_type: ::std::os::raw::c_uint,
        locatable: ::std::os::raw::c_uint,
        prefetchable: ::std::os::raw::c_uint,
        base_address: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let region_type: u32 = unsafe { ::std::mem::transmute(region_type) };
            region_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let locatable: u32 = unsafe { ::std::mem::transmute(locatable) };
            locatable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let prefetchable: u32 = unsafe { ::std::mem::transmute(prefetchable) };
            prefetchable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let base_address: u32 = unsafe { ::std::mem::transmute(base_address) };
            base_address as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_bar_t__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_vfu_bar_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<vfu_bar_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(vfu_bar_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_bar_t__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(vfu_bar_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl vfu_bar_t__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn region_type(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_region_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn base_address(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_base_address(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        region_type: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
        base_address: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let region_type: u32 = unsafe { ::std::mem::transmute(region_type) };
            region_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let base_address: u32 = unsafe { ::std::mem::transmute(base_address) };
            base_address as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_vfu_bar_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_bar_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(vfu_bar_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_bar_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_bar_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_bar_t__bindgen_ty_1>())).mem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_bar_t__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_bar_t__bindgen_ty_1>())).io as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_bar_t__bindgen_ty_1),
            "::",
            stringify!(io)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_bar_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_bar_t>(),
        4usize,
        concat!("Size of: ", stringify!(vfu_bar_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_bar_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_bar_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_bar_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_bar_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_htype_t {
    pub raw: u8,
    _bindgen_union_align: u8,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_htype_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_htype_t>(),
        1usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_htype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_htype_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_htype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_htype_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_htype_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_cc_t {
    pub raw: [u8; 3usize],
    pub __bindgen_anon_1: vfu_pci_hdr_cc_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_pci_hdr_cc_t__bindgen_ty_1 {
    pub pi: u8,
    pub scc: u8,
    pub bcc: u8,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_cc_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_cc_t__bindgen_ty_1>(),
        3usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_cc_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_cc_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_cc_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_cc_t__bindgen_ty_1>())).pi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_cc_t__bindgen_ty_1),
            "::",
            stringify!(pi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_cc_t__bindgen_ty_1>())).scc as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_cc_t__bindgen_ty_1),
            "::",
            stringify!(scc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_cc_t__bindgen_ty_1>())).bcc as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_cc_t__bindgen_ty_1),
            "::",
            stringify!(bcc)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_cc_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_cc_t>(),
        3usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_cc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_cc_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_cc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_cc_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_cc_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_sts_t {
    pub raw: u16,
    pub __bindgen_anon_1: vfu_pci_hdr_sts_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_pci_hdr_sts_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_sts_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_sts_t__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_sts_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_sts_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_sts_t__bindgen_ty_1))
    );
}
impl vfu_pci_hdr_sts_t__bindgen_ty_1 {
    #[inline]
    pub fn res1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn is(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn c66(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_c66(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fbc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fbc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpd(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dpd(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn devt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_devt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sta(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sta(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rta(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rta(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rma(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rma(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sse(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sse(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpe(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dpe(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: ::std::os::raw::c_uint,
        is: ::std::os::raw::c_uint,
        cl: ::std::os::raw::c_uint,
        c66: ::std::os::raw::c_uint,
        res2: ::std::os::raw::c_uint,
        fbc: ::std::os::raw::c_uint,
        dpd: ::std::os::raw::c_uint,
        devt: ::std::os::raw::c_uint,
        sta: ::std::os::raw::c_uint,
        rta: ::std::os::raw::c_uint,
        rma: ::std::os::raw::c_uint,
        sse: ::std::os::raw::c_uint,
        dpe: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is: u32 = unsafe { ::std::mem::transmute(is) };
            is as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let cl: u32 = unsafe { ::std::mem::transmute(cl) };
            cl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let c66: u32 = unsafe { ::std::mem::transmute(c66) };
            c66 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fbc: u32 = unsafe { ::std::mem::transmute(fbc) };
            fbc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dpd: u32 = unsafe { ::std::mem::transmute(dpd) };
            dpd as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let devt: u32 = unsafe { ::std::mem::transmute(devt) };
            devt as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sta: u32 = unsafe { ::std::mem::transmute(sta) };
            sta as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rta: u32 = unsafe { ::std::mem::transmute(rta) };
            rta as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rma: u32 = unsafe { ::std::mem::transmute(rma) };
            rma as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sse: u32 = unsafe { ::std::mem::transmute(sse) };
            sse as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dpe: u32 = unsafe { ::std::mem::transmute(dpe) };
            dpe as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_sts_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_sts_t>(),
        2usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_sts_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_sts_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_sts_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_sts_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_sts_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_cmd_t {
    pub raw: u16,
    pub __bindgen_anon_1: vfu_pci_hdr_cmd_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_pci_hdr_cmd_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_cmd_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_cmd_t__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_cmd_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_cmd_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_cmd_t__bindgen_ty_1))
    );
}
impl vfu_pci_hdr_cmd_t__bindgen_ty_1 {
    #[inline]
    pub fn iose(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_iose(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mse(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mse(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bme(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bme(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sce(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sce(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mwie(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mwie(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vga(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vga(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pee(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pee(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn see(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_see(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fbe(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fbe(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn id(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_id(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        iose: u8,
        mse: u8,
        bme: u8,
        sce: u8,
        mwie: u8,
        vga: u8,
        pee: u8,
        zero: u8,
        see: u8,
        fbe: u8,
        id: u8,
        res1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let iose: u8 = unsafe { ::std::mem::transmute(iose) };
            iose as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mse: u8 = unsafe { ::std::mem::transmute(mse) };
            mse as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bme: u8 = unsafe { ::std::mem::transmute(bme) };
            bme as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sce: u8 = unsafe { ::std::mem::transmute(sce) };
            sce as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mwie: u8 = unsafe { ::std::mem::transmute(mwie) };
            mwie as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let vga: u8 = unsafe { ::std::mem::transmute(vga) };
            vga as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pee: u8 = unsafe { ::std::mem::transmute(pee) };
            pee as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let zero: u8 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let see: u8 = unsafe { ::std::mem::transmute(see) };
            see as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fbe: u8 = unsafe { ::std::mem::transmute(fbe) };
            fbe as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let id: u8 = unsafe { ::std::mem::transmute(id) };
            id as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let res1: u8 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_cmd_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_cmd_t>(),
        2usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_cmd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_cmd_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_cmd_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_cmd_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_cmd_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_id_t {
    pub raw: u32,
    pub __bindgen_anon_1: vfu_pci_hdr_id_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_pci_hdr_id_t__bindgen_ty_1 {
    pub vid: u16,
    pub did: u16,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_id_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_id_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_id_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_id_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_id_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_id_t__bindgen_ty_1>())).vid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_id_t__bindgen_ty_1),
            "::",
            stringify!(vid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_id_t__bindgen_ty_1>())).did as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_id_t__bindgen_ty_1),
            "::",
            stringify!(did)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_id_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_id_t>(),
        4usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_id_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_id_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_id_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_intr_t {
    pub raw: u16,
    pub __bindgen_anon_1: vfu_pci_hdr_intr_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_pci_hdr_intr_t__bindgen_ty_1 {
    pub iline: u8,
    pub ipin: u8,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_intr_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_intr_t__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_intr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_intr_t__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(vfu_pci_hdr_intr_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_intr_t__bindgen_ty_1>())).iline as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_intr_t__bindgen_ty_1),
            "::",
            stringify!(iline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_intr_t__bindgen_ty_1>())).ipin as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_intr_t__bindgen_ty_1),
            "::",
            stringify!(ipin)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_intr_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_intr_t>(),
        2usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_intr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_intr_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_intr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_intr_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_intr_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_hdr_t {
    pub raw: [u8; 64usize],
    pub __bindgen_anon_1: vfu_pci_hdr_t__bindgen_ty_1,
    _bindgen_union_align: [u8; 64usize],
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct vfu_pci_hdr_t__bindgen_ty_1 {
    pub id: vfu_pci_hdr_id_t,
    pub cmd: vfu_pci_hdr_cmd_t,
    pub sts: vfu_pci_hdr_sts_t,
    pub rid: u8,
    pub cc: vfu_pci_hdr_cc_t,
    pub cls: u8,
    pub mlt: u8,
    pub htype: vfu_pci_hdr_htype_t,
    pub bist: vfu_pci_hdr_bist_t,
    pub bars: [vfu_bar_t; 6usize],
    pub ccptr: u32,
    pub ss: vfu_pci_hdr_ss_t,
    pub erom: u32,
    pub cap: u8,
    pub res1: [u8; 7usize],
    pub intr: vfu_pci_hdr_intr_t,
    pub mgnt: u8,
    pub mlat: u8,
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_t__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).cmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).sts as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(sts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).rid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(rid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).cc as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(cc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).cls as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).mlt as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(mlt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).htype as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(htype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).bist as *const _ as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(bist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).bars as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(bars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).ccptr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(ccptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).ss as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).erom as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(erom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).cap as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).res1 as *const _ as usize
        },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(res1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).intr as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(intr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).mgnt as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(mgnt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_hdr_t__bindgen_ty_1>())).mlat as *const _ as usize
        },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t__bindgen_ty_1),
            "::",
            stringify!(mlat)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_pci_hdr_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_hdr_t>(),
        64usize,
        concat!("Size of: ", stringify!(vfu_pci_hdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_hdr_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_hdr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_pci_hdr_t>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_hdr_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
pub struct vfu_pci_config_space_t {
    pub __bindgen_anon_1: vfu_pci_config_space_t__bindgen_ty_1,
    pub extended: __IncompleteArrayField<u8>,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union vfu_pci_config_space_t__bindgen_ty_1 {
    pub raw: [u8; 256usize],
    pub hdr: vfu_pci_hdr_t,
    _bindgen_union_align: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_vfu_pci_config_space_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_config_space_t__bindgen_ty_1>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(vfu_pci_config_space_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_config_space_t__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(vfu_pci_config_space_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_config_space_t__bindgen_ty_1>())).raw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_config_space_t__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_pci_config_space_t__bindgen_ty_1>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_pci_config_space_t__bindgen_ty_1),
            "::",
            stringify!(hdr)
        )
    );
}
#[test]
fn bindgen_test_layout_vfu_pci_config_space_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_pci_config_space_t>(),
        256usize,
        concat!("Size of: ", stringify!(vfu_pci_config_space_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_pci_config_space_t>(),
        1usize,
        concat!("Alignment of ", stringify!(vfu_pci_config_space_t))
    );
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_info_cap_header {
    pub id: __u16,
    pub version: __u16,
    pub next: __u32,
}
#[test]
fn bindgen_test_layout_vfio_info_cap_header() {
    assert_eq!(
        ::std::mem::size_of::<vfio_info_cap_header>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_info_cap_header))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_info_cap_header>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_info_cap_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_info_cap_header>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_info_cap_header),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_info_cap_header>())).version as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_info_cap_header),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_info_cap_header>())).next as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_info_cap_header),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_group_status {
    pub argsz: __u32,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_vfio_group_status() {
    assert_eq!(
        ::std::mem::size_of::<vfio_group_status>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_group_status))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_group_status>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_group_status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_group_status>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_group_status),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_group_status>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_group_status),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_device_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub num_regions: __u32,
    pub num_irqs: __u32,
    pub cap_offset: __u32,
}
#[test]
fn bindgen_test_layout_vfio_device_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_info>(),
        20usize,
        concat!("Size of: ", stringify!(vfio_device_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_device_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_info>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_info),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_info>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_info>())).num_regions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_info),
            "::",
            stringify!(num_regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_info>())).num_irqs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_info),
            "::",
            stringify!(num_irqs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_info>())).cap_offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_info),
            "::",
            stringify!(cap_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub cap_offset: __u32,
    pub size: __u64,
    pub offset: __u64,
}
#[test]
fn bindgen_test_layout_vfio_region_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_region_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_region_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info>())).cap_offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info),
            "::",
            stringify!(cap_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_sparse_mmap_area {
    pub offset: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_region_sparse_mmap_area() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_sparse_mmap_area>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_sparse_mmap_area))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_sparse_mmap_area>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_region_sparse_mmap_area))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_sparse_mmap_area>())).offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_sparse_mmap_area),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_sparse_mmap_area>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_sparse_mmap_area),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_region_info_cap_sparse_mmap {
    pub header: vfio_info_cap_header,
    pub nr_areas: __u32,
    pub reserved: __u32,
    pub areas: __IncompleteArrayField<vfio_region_sparse_mmap_area>,
}
#[test]
fn bindgen_test_layout_vfio_region_info_cap_sparse_mmap() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info_cap_sparse_mmap>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_info_cap_sparse_mmap))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info_cap_sparse_mmap>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_region_info_cap_sparse_mmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info_cap_type {
    pub header: vfio_info_cap_header,
    pub type_: __u32,
    pub subtype: __u32,
}
#[test]
fn bindgen_test_layout_vfio_region_info_cap_type() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info_cap_type>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_info_cap_type))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info_cap_type>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_region_info_cap_type))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_type>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_type),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_info_cap_type>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_type),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_type>())).subtype as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_type),
            "::",
            stringify!(subtype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_gfx_edid {
    pub edid_offset: __u32,
    pub edid_max_size: __u32,
    pub edid_size: __u32,
    pub max_xres: __u32,
    pub max_yres: __u32,
    pub link_state: __u32,
}
#[test]
fn bindgen_test_layout_vfio_region_gfx_edid() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_gfx_edid>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_region_gfx_edid))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_gfx_edid>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_region_gfx_edid))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_gfx_edid>())).edid_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_gfx_edid),
            "::",
            stringify!(edid_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_gfx_edid>())).edid_max_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_gfx_edid),
            "::",
            stringify!(edid_max_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_gfx_edid>())).edid_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_gfx_edid),
            "::",
            stringify!(edid_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_gfx_edid>())).max_xres as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_gfx_edid),
            "::",
            stringify!(max_xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_gfx_edid>())).max_yres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_gfx_edid),
            "::",
            stringify!(max_yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_region_gfx_edid>())).link_state as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_gfx_edid),
            "::",
            stringify!(link_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_device_migration_info {
    pub device_state: __u32,
    pub reserved: __u32,
    pub pending_bytes: __u64,
    pub data_offset: __u64,
    pub data_size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_device_migration_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_migration_info>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_device_migration_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_migration_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_device_migration_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_migration_info>())).device_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_migration_info),
            "::",
            stringify!(device_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_migration_info>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_migration_info),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_migration_info>())).pending_bytes as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_migration_info),
            "::",
            stringify!(pending_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_migration_info>())).data_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_migration_info),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_migration_info>())).data_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_migration_info),
            "::",
            stringify!(data_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info_cap_nvlink2_ssatgt {
    pub header: vfio_info_cap_header,
    pub tgt: __u64,
}
#[test]
fn bindgen_test_layout_vfio_region_info_cap_nvlink2_ssatgt() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info_cap_nvlink2_ssatgt>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_info_cap_nvlink2_ssatgt))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info_cap_nvlink2_ssatgt>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_region_info_cap_nvlink2_ssatgt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_nvlink2_ssatgt>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_nvlink2_ssatgt),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_nvlink2_ssatgt>())).tgt as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_nvlink2_ssatgt),
            "::",
            stringify!(tgt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_region_info_cap_nvlink2_lnkspd {
    pub header: vfio_info_cap_header,
    pub link_speed: __u32,
    pub __pad: __u32,
}
#[test]
fn bindgen_test_layout_vfio_region_info_cap_nvlink2_lnkspd() {
    assert_eq!(
        ::std::mem::size_of::<vfio_region_info_cap_nvlink2_lnkspd>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_region_info_cap_nvlink2_lnkspd))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_region_info_cap_nvlink2_lnkspd>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_region_info_cap_nvlink2_lnkspd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_nvlink2_lnkspd>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_nvlink2_lnkspd),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_nvlink2_lnkspd>())).link_speed as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_nvlink2_lnkspd),
            "::",
            stringify!(link_speed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_region_info_cap_nvlink2_lnkspd>())).__pad as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_region_info_cap_nvlink2_lnkspd),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_irq_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub count: __u32,
}
#[test]
fn bindgen_test_layout_vfio_irq_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_irq_info>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_irq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_irq_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_irq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_irq_info>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_irq_info),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_irq_info>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_irq_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_irq_info>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_irq_info),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_irq_info>())).count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_irq_info),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_irq_set {
    pub argsz: __u32,
    pub flags: __u32,
    pub index: __u32,
    pub start: __u32,
    pub count: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_vfio_irq_set() {
    assert_eq!(
        ::std::mem::size_of::<vfio_irq_set>(),
        20usize,
        concat!("Size of: ", stringify!(vfio_irq_set))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_irq_set>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_irq_set))
    );
}
pub const VFIO_PCI_BAR0_REGION_INDEX: ::std::os::raw::c_uint = 0;
pub const VFIO_PCI_BAR1_REGION_INDEX: ::std::os::raw::c_uint = 1;
pub const VFIO_PCI_BAR2_REGION_INDEX: ::std::os::raw::c_uint = 2;
pub const VFIO_PCI_BAR3_REGION_INDEX: ::std::os::raw::c_uint = 3;
pub const VFIO_PCI_BAR4_REGION_INDEX: ::std::os::raw::c_uint = 4;
pub const VFIO_PCI_BAR5_REGION_INDEX: ::std::os::raw::c_uint = 5;
pub const VFIO_PCI_ROM_REGION_INDEX: ::std::os::raw::c_uint = 6;
pub const VFIO_PCI_CONFIG_REGION_INDEX: ::std::os::raw::c_uint = 7;
pub const VFIO_PCI_VGA_REGION_INDEX: ::std::os::raw::c_uint = 8;
pub const VFIO_PCI_NUM_REGIONS: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const VFIO_PCI_INTX_IRQ_INDEX: ::std::os::raw::c_uint = 0;
pub const VFIO_PCI_MSI_IRQ_INDEX: ::std::os::raw::c_uint = 1;
pub const VFIO_PCI_MSIX_IRQ_INDEX: ::std::os::raw::c_uint = 2;
pub const VFIO_PCI_ERR_IRQ_INDEX: ::std::os::raw::c_uint = 3;
pub const VFIO_PCI_REQ_IRQ_INDEX: ::std::os::raw::c_uint = 4;
pub const VFIO_PCI_NUM_IRQS: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const VFIO_CCW_CONFIG_REGION_INDEX: ::std::os::raw::c_uint = 0;
pub const VFIO_CCW_NUM_REGIONS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const VFIO_CCW_IO_IRQ_INDEX: ::std::os::raw::c_uint = 0;
pub const VFIO_CCW_CRW_IRQ_INDEX: ::std::os::raw::c_uint = 1;
pub const VFIO_CCW_REQ_IRQ_INDEX: ::std::os::raw::c_uint = 2;
pub const VFIO_CCW_NUM_IRQS: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_pci_dependent_device {
    pub group_id: __u32,
    pub segment: __u16,
    pub bus: __u8,
    pub devfn: __u8,
}
#[test]
fn bindgen_test_layout_vfio_pci_dependent_device() {
    assert_eq!(
        ::std::mem::size_of::<vfio_pci_dependent_device>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_pci_dependent_device))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_pci_dependent_device>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_pci_dependent_device))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_pci_dependent_device>())).group_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_pci_dependent_device),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_pci_dependent_device>())).segment as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_pci_dependent_device),
            "::",
            stringify!(segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_pci_dependent_device>())).bus as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_pci_dependent_device),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_pci_dependent_device>())).devfn as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_pci_dependent_device),
            "::",
            stringify!(devfn)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_pci_hot_reset_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub devices: __IncompleteArrayField<vfio_pci_dependent_device>,
}
#[test]
fn bindgen_test_layout_vfio_pci_hot_reset_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_pci_hot_reset_info>(),
        12usize,
        concat!("Size of: ", stringify!(vfio_pci_hot_reset_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_pci_hot_reset_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_pci_hot_reset_info))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_pci_hot_reset {
    pub argsz: __u32,
    pub flags: __u32,
    pub count: __u32,
    pub group_fds: __IncompleteArrayField<__s32>,
}
#[test]
fn bindgen_test_layout_vfio_pci_hot_reset() {
    assert_eq!(
        ::std::mem::size_of::<vfio_pci_hot_reset>(),
        12usize,
        concat!("Size of: ", stringify!(vfio_pci_hot_reset))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_pci_hot_reset>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_pci_hot_reset))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_device_gfx_plane_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub drm_plane_type: __u32,
    pub drm_format: __u32,
    pub drm_format_mod: __u64,
    pub width: __u32,
    pub height: __u32,
    pub stride: __u32,
    pub size: __u32,
    pub x_pos: __u32,
    pub y_pos: __u32,
    pub x_hot: __u32,
    pub y_hot: __u32,
    pub __bindgen_anon_1: vfio_device_gfx_plane_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_device_gfx_plane_info__bindgen_ty_1 {
    pub region_index: __u32,
    pub dmabuf_id: __u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_vfio_device_gfx_plane_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_gfx_plane_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(vfio_device_gfx_plane_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_gfx_plane_info__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_device_gfx_plane_info__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info__bindgen_ty_1>())).region_index
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info__bindgen_ty_1),
            "::",
            stringify!(region_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info__bindgen_ty_1>())).dmabuf_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info__bindgen_ty_1),
            "::",
            stringify!(dmabuf_id)
        )
    );
}
#[test]
fn bindgen_test_layout_vfio_device_gfx_plane_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_gfx_plane_info>(),
        64usize,
        concat!("Size of: ", stringify!(vfio_device_gfx_plane_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_gfx_plane_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_device_gfx_plane_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).argsz as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).drm_plane_type as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(drm_plane_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).drm_format as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(drm_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).drm_format_mod as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(drm_format_mod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).width as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).height as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).stride as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).x_pos as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(x_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).y_pos as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(y_pos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).x_hot as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(x_hot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_device_gfx_plane_info>())).y_hot as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_gfx_plane_info),
            "::",
            stringify!(y_hot)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_device_ioeventfd {
    pub argsz: __u32,
    pub flags: __u32,
    pub offset: __u64,
    pub data: __u64,
    pub fd: __s32,
}
#[test]
fn bindgen_test_layout_vfio_device_ioeventfd() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_ioeventfd>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_device_ioeventfd))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_ioeventfd>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_device_ioeventfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_ioeventfd>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_ioeventfd),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_ioeventfd>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_ioeventfd),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_ioeventfd>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_ioeventfd),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_ioeventfd>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_ioeventfd),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_device_ioeventfd>())).fd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_device_ioeventfd),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_device_feature {
    pub argsz: __u32,
    pub flags: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_vfio_device_feature() {
    assert_eq!(
        ::std::mem::size_of::<vfio_device_feature>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_device_feature))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_device_feature>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_device_feature))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova_pgsizes: __u64,
    pub cap_offset: __u32,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_info>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_info>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_info>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info>())).iova_pgsizes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info),
            "::",
            stringify!(iova_pgsizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info>())).cap_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info),
            "::",
            stringify!(cap_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iova_range {
    pub start: __u64,
    pub end: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iova_range() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iova_range>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_iova_range))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iova_range>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iova_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iova_range>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iova_range),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iova_range>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iova_range),
            "::",
            stringify!(end)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_iommu_type1_info_cap_iova_range {
    pub header: vfio_info_cap_header,
    pub nr_iovas: __u32,
    pub reserved: __u32,
    pub iova_ranges: __IncompleteArrayField<vfio_iova_range>,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_info_cap_iova_range() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_info_cap_iova_range>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(vfio_iommu_type1_info_cap_iova_range)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_info_cap_iova_range>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_iommu_type1_info_cap_iova_range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_info_cap_migration {
    pub header: vfio_info_cap_header,
    pub flags: __u32,
    pub pgsize_bitmap: __u64,
    pub max_dirty_bitmap_size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_info_cap_migration() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_info_cap_migration>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_info_cap_migration))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_info_cap_migration>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_iommu_type1_info_cap_migration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info_cap_migration>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info_cap_migration),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info_cap_migration>())).flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info_cap_migration),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info_cap_migration>())).pgsize_bitmap
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info_cap_migration),
            "::",
            stringify!(pgsize_bitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info_cap_migration>())).max_dirty_bitmap_size
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info_cap_migration),
            "::",
            stringify!(max_dirty_bitmap_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_info_dma_avail {
    pub header: vfio_info_cap_header,
    pub avail: __u32,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_info_dma_avail() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_info_dma_avail>(),
        12usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_info_dma_avail))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_info_dma_avail>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_info_dma_avail))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info_dma_avail>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info_dma_avail),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_info_dma_avail>())).avail as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_info_dma_avail),
            "::",
            stringify!(avail)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_dma_map {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub iova: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_dma_map() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_dma_map>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_dma_map))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_dma_map>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_dma_map))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_dma_map>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dma_map),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_dma_map>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dma_map),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_dma_map>())).vaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dma_map),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_dma_map>())).iova as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dma_map),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_type1_dma_map>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dma_map),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_bitmap {
    pub pgsize: __u64,
    pub size: __u64,
    pub data: *mut __u64,
}
#[test]
fn bindgen_test_layout_vfio_bitmap() {
    assert_eq!(
        ::std::mem::size_of::<vfio_bitmap>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_bitmap>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_bitmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_bitmap>())).pgsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_bitmap),
            "::",
            stringify!(pgsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_bitmap>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_bitmap),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_bitmap>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_bitmap),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_iommu_type1_dma_unmap {
    pub argsz: __u32,
    pub flags: __u32,
    pub iova: __u64,
    pub size: __u64,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_dma_unmap() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_dma_unmap>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_dma_unmap))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_dma_unmap>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_dma_unmap))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct vfio_iommu_type1_dirty_bitmap {
    pub argsz: __u32,
    pub flags: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_dirty_bitmap() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_dirty_bitmap>(),
        8usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_dirty_bitmap))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_dirty_bitmap>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_iommu_type1_dirty_bitmap))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_type1_dirty_bitmap_get {
    pub iova: __u64,
    pub size: __u64,
    pub bitmap: vfio_bitmap,
}
#[test]
fn bindgen_test_layout_vfio_iommu_type1_dirty_bitmap_get() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_type1_dirty_bitmap_get>(),
        40usize,
        concat!("Size of: ", stringify!(vfio_iommu_type1_dirty_bitmap_get))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_type1_dirty_bitmap_get>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_iommu_type1_dirty_bitmap_get)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_dirty_bitmap_get>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dirty_bitmap_get),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_dirty_bitmap_get>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dirty_bitmap_get),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_type1_dirty_bitmap_get>())).bitmap as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_type1_dirty_bitmap_get),
            "::",
            stringify!(bitmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_ddw_info {
    pub pgsizes: __u64,
    pub max_dynamic_windows_supported: __u32,
    pub levels: __u32,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_ddw_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_ddw_info>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_ddw_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_ddw_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_ddw_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_ddw_info>())).pgsizes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_ddw_info),
            "::",
            stringify!(pgsizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_ddw_info>())).max_dynamic_windows_supported
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_ddw_info),
            "::",
            stringify!(max_dynamic_windows_supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_ddw_info>())).levels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_ddw_info),
            "::",
            stringify!(levels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_info {
    pub argsz: __u32,
    pub flags: __u32,
    pub dma32_window_start: __u32,
    pub dma32_window_size: __u32,
    pub ddw: vfio_iommu_spapr_tce_ddw_info,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_info>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_spapr_tce_info>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_info),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_spapr_tce_info>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_info>())).dma32_window_start as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_info),
            "::",
            stringify!(dma32_window_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_info>())).dma32_window_size as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_info),
            "::",
            stringify!(dma32_window_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_iommu_spapr_tce_info>())).ddw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_info),
            "::",
            stringify!(ddw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_eeh_pe_err {
    pub type_: __u32,
    pub func: __u32,
    pub addr: __u64,
    pub mask: __u64,
}
#[test]
fn bindgen_test_layout_vfio_eeh_pe_err() {
    assert_eq!(
        ::std::mem::size_of::<vfio_eeh_pe_err>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_eeh_pe_err))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_eeh_pe_err>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_eeh_pe_err))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_err>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_err),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_err>())).func as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_err),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_err>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_err),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_err>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_err),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfio_eeh_pe_op {
    pub argsz: __u32,
    pub flags: __u32,
    pub op: __u32,
    pub __bindgen_anon_1: vfio_eeh_pe_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vfio_eeh_pe_op__bindgen_ty_1 {
    pub err: vfio_eeh_pe_err,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_vfio_eeh_pe_op__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfio_eeh_pe_op__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_eeh_pe_op__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_eeh_pe_op__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_eeh_pe_op__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_eeh_pe_op__bindgen_ty_1>())).err as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_op__bindgen_ty_1),
            "::",
            stringify!(err)
        )
    );
}
#[test]
fn bindgen_test_layout_vfio_eeh_pe_op() {
    assert_eq!(
        ::std::mem::size_of::<vfio_eeh_pe_op>(),
        40usize,
        concat!("Size of: ", stringify!(vfio_eeh_pe_op))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_eeh_pe_op>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_eeh_pe_op))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_op>())).argsz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_op),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_op>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_op),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_eeh_pe_op>())).op as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_eeh_pe_op),
            "::",
            stringify!(op)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_register_memory {
    pub argsz: __u32,
    pub flags: __u32,
    pub vaddr: __u64,
    pub size: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_register_memory() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_register_memory>(),
        24usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_register_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_register_memory>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vfio_iommu_spapr_register_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_register_memory>())).argsz as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_register_memory),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_register_memory>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_register_memory),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_register_memory>())).vaddr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_register_memory),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_register_memory>())).size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_register_memory),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_create {
    pub argsz: __u32,
    pub flags: __u32,
    pub page_shift: __u32,
    pub __resv1: __u32,
    pub window_size: __u64,
    pub levels: __u32,
    pub __resv2: __u32,
    pub start_addr: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_create() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_create>(),
        40usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_create))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_create>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_create))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).argsz as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).page_shift as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(page_shift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).__resv1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(__resv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).window_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(window_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).levels as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(levels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).__resv2 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(__resv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_create>())).start_addr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_create),
            "::",
            stringify!(start_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_iommu_spapr_tce_remove {
    pub argsz: __u32,
    pub flags: __u32,
    pub start_addr: __u64,
}
#[test]
fn bindgen_test_layout_vfio_iommu_spapr_tce_remove() {
    assert_eq!(
        ::std::mem::size_of::<vfio_iommu_spapr_tce_remove>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_iommu_spapr_tce_remove))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_iommu_spapr_tce_remove>(),
        8usize,
        concat!("Alignment of ", stringify!(vfio_iommu_spapr_tce_remove))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_remove>())).argsz as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_remove),
            "::",
            stringify!(argsz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_remove>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_remove),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfio_iommu_spapr_tce_remove>())).start_addr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_iommu_spapr_tce_remove),
            "::",
            stringify!(start_addr)
        )
    );
}
pub const vfio_user_command_VFIO_USER_VERSION: vfio_user_command = 1;
pub const vfio_user_command_VFIO_USER_DMA_MAP: vfio_user_command = 2;
pub const vfio_user_command_VFIO_USER_DMA_UNMAP: vfio_user_command = 3;
pub const vfio_user_command_VFIO_USER_DEVICE_GET_INFO: vfio_user_command = 4;
pub const vfio_user_command_VFIO_USER_DEVICE_GET_REGION_INFO: vfio_user_command = 5;
pub const vfio_user_command_VFIO_USER_DEVICE_GET_IRQ_INFO: vfio_user_command = 6;
pub const vfio_user_command_VFIO_USER_DEVICE_SET_IRQS: vfio_user_command = 7;
pub const vfio_user_command_VFIO_USER_REGION_READ: vfio_user_command = 8;
pub const vfio_user_command_VFIO_USER_REGION_WRITE: vfio_user_command = 9;
pub const vfio_user_command_VFIO_USER_DMA_READ: vfio_user_command = 10;
pub const vfio_user_command_VFIO_USER_DMA_WRITE: vfio_user_command = 11;
pub const vfio_user_command_VFIO_USER_VM_INTERRUPT: vfio_user_command = 12;
pub const vfio_user_command_VFIO_USER_DEVICE_RESET: vfio_user_command = 13;
pub const vfio_user_command_VFIO_USER_DIRTY_PAGES: vfio_user_command = 14;
pub const vfio_user_command_VFIO_USER_MAX: vfio_user_command = 15;
pub type vfio_user_command = ::std::os::raw::c_uint;
pub const vfio_user_message_type_VFIO_USER_MESSAGE_COMMAND: vfio_user_message_type = 0;
pub const vfio_user_message_type_VFIO_USER_MESSAGE_REPLY: vfio_user_message_type = 1;
pub type vfio_user_message_type = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_user_header {
    pub msg_id: u16,
    pub cmd: u16,
    pub msg_size: u32,
    pub flags: vfio_user_header__bindgen_ty_1,
    pub error_no: u32,
}
#[repr(C)]
//#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct vfio_user_header__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_vfio_user_header__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_header__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(vfio_user_header__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_header__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(vfio_user_header__bindgen_ty_1))
    );
}
impl vfio_user_header__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn no_reply(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_reply(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resvd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_resvd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u32,
        no_reply: u32,
        error: u32,
        resvd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let no_reply: u32 = unsafe { ::std::mem::transmute(no_reply) };
            no_reply as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let error: u32 = unsafe { ::std::mem::transmute(error) };
            error as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let resvd: u32 = unsafe { ::std::mem::transmute(resvd) };
            resvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_vfio_user_header() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_header>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_user_header))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_header>(),
        1usize,
        concat!("Alignment of ", stringify!(vfio_user_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_header>())).msg_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_header),
            "::",
            stringify!(msg_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_header>())).cmd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_header),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_header>())).msg_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_header),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_header>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_header),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_header>())).error_no as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_header),
            "::",
            stringify!(error_no)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct vfio_user_version {
    pub major: u16,
    pub minor: u16,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_vfio_user_version() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_version>(),
        4usize,
        concat!("Size of: ", stringify!(vfio_user_version))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_version>(),
        1usize,
        concat!("Alignment of ", stringify!(vfio_user_version))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_user_dma_region {
    pub addr: u64,
    pub size: u64,
    pub offset: u64,
    pub prot: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_vfio_user_dma_region() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_dma_region>(),
        32usize,
        concat!("Size of: ", stringify!(vfio_user_dma_region))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_dma_region>(),
        1usize,
        concat!("Alignment of ", stringify!(vfio_user_dma_region))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_dma_region>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_dma_region),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_dma_region>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_dma_region),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_dma_region>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_dma_region),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_dma_region>())).prot as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_dma_region),
            "::",
            stringify!(prot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_dma_region>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_dma_region),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct vfio_user_region_access {
    pub offset: u64,
    pub region: u32,
    pub count: u32,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_vfio_user_region_access() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_region_access>(),
        16usize,
        concat!("Size of: ", stringify!(vfio_user_region_access))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_region_access>(),
        1usize,
        concat!("Alignment of ", stringify!(vfio_user_region_access))
    );
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct vfio_user_dma_region_access {
    pub addr: u64,
    pub count: u32,
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_vfio_user_dma_region_access() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_dma_region_access>(),
        12usize,
        concat!("Size of: ", stringify!(vfio_user_dma_region_access))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_dma_region_access>(),
        1usize,
        concat!("Alignment of ", stringify!(vfio_user_dma_region_access))
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct vfio_user_irq_info {
    pub subindex: u32,
}
#[test]
fn bindgen_test_layout_vfio_user_irq_info() {
    assert_eq!(
        ::std::mem::size_of::<vfio_user_irq_info>(),
        4usize,
        concat!("Size of: ", stringify!(vfio_user_irq_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfio_user_irq_info>(),
        1usize,
        concat!("Alignment of ", stringify!(vfio_user_irq_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfio_user_irq_info>())).subindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfio_user_irq_info),
            "::",
            stringify!(subindex)
        )
    );
}
pub type vfu_dma_addr_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dma_sg_t {
    pub dma_addr: vfu_dma_addr_t,
    pub region: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub offset: u64,
    pub mappable: bool,
}
#[test]
fn bindgen_test_layout_dma_sg_t() {
    assert_eq!(
        ::std::mem::size_of::<dma_sg_t>(),
        32usize,
        concat!("Size of: ", stringify!(dma_sg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<dma_sg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(dma_sg_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dma_sg_t>())).dma_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_sg_t),
            "::",
            stringify!(dma_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dma_sg_t>())).region as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_sg_t),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dma_sg_t>())).length as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_sg_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dma_sg_t>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_sg_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dma_sg_t>())).mappable as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dma_sg_t),
            "::",
            stringify!(mappable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_ctx {
    _unused: [u8; 0],
}
pub type vfu_ctx_t = vfu_ctx;
pub const vfu_trans_t_VFU_TRANS_SOCK: vfu_trans_t = 0;
pub const vfu_trans_t_VFU_TRANS_MAX: vfu_trans_t = 1;
pub type vfu_trans_t = ::std::os::raw::c_uint;
pub const vfu_dev_type_t_VFU_DEV_TYPE_PCI: vfu_dev_type_t = 0;
pub type vfu_dev_type_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Creates libvfio-user context. By default one ERR and one REQ IRQs are"]
    #[doc = " initialized, this can be overridden with vfu_setup_device_nr_irqs."]
    #[doc = ""]
    #[doc = " @trans: transport type"]
    #[doc = " @path: path to socket file."]
    #[doc = " @flags: context flags"]
    #[doc = " @pvt: private data"]
    #[doc = " @dev_type: device type"]
    #[doc = ""]
    #[doc = " @returns the vfu_ctx to be used or NULL on error. Sets errno."]
    pub fn vfu_create_ctx(
        trans: vfu_trans_t,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        pvt: *mut ::std::os::raw::c_void,
        dev_type: vfu_dev_type_t,
    ) -> *mut vfu_ctx_t;
}
extern "C" {
    pub fn vfu_realize_ctx(vfu_ctx: *mut vfu_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfu_attach_ctx(vfu_ctx: *mut vfu_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a file descriptor suitable for waiting on via epoll() or similar. This"]
    #[doc = " should not be cached, as it may change after a successful vfu_attach_ctx()."]
    pub fn vfu_get_poll_fd(vfu_ctx: *mut vfu_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Polls the vfu_ctx and processes the command received from client."]
    #[doc = " - Blocking vfu_ctx:"]
    #[doc = "   Blocks until new request is received from client and continues processing"]
    #[doc = "   the requests. Exits only in case of error or if the client disconnects."]
    #[doc = " - Non-blocking vfu_ctx(LIBVFIO_USER_FLAG_ATTACH_NB):"]
    #[doc = "   Processes one request from client if it's available, otherwise it"]
    #[doc = "   immediately returns and the caller is responsible for periodically"]
    #[doc = "   calling again."]
    #[doc = ""]
    #[doc = " @vfu_ctx: The libvfio-user context to poll"]
    #[doc = ""]
    #[doc = " @returns 0 on success, -1 on error, with errno set as follows:"]
    #[doc = ""]
    #[doc = " EAGAIN/EWOULDBLOCK: no more commands to process"]
    #[doc = " ENOTCONN: client closed connection, vfu_attach_ctx() should be called again"]
    #[doc = " Other errno values are also possible."]
    pub fn vfu_run_ctx(vfu_ctx: *mut vfu_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroys libvfio-user context."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context to destroy"]
    pub fn vfu_destroy_ctx(vfu_ctx: *mut vfu_ctx_t);
}
extern "C" {
    #[doc = " Return the private pointer given to vfu_create_ctx()."]
    pub fn vfu_get_private(vfu_ctx: *mut vfu_ctx_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " Callback function signature for log function"]
#[doc = " @vfu_ctx: the libvfio-user context"]
#[doc = " @level: log level as defined in syslog(3)"]
#[doc = " @vfu_log_fn_t: typedef for log function."]
#[doc = " @msg: message"]
pub type vfu_log_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vfu_ctx: *mut vfu_ctx_t,
        level: ::std::os::raw::c_int,
        msg: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Log to the logging function configured for this context. The format should"]
    #[doc = " not include a new line."]
    pub fn vfu_log(
        vfu_ctx: *mut vfu_ctx_t,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Set up logging information."]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @log: logging function"]
    #[doc = " @level: logging level as defined in syslog(3)"]
    #[doc = ""]
    #[doc = " The log handler is expected to add a newline (that is, log messages do not"]
    #[doc = " include a newline)."]
    pub fn vfu_setup_log(
        vfu_ctx: *mut vfu_ctx_t,
        log: vfu_log_fn_t,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Prototype for region access callback. When a region is accessed, libvfio-user"]
#[doc = " calls the previously registered callback with the following arguments:"]
#[doc = ""]
#[doc = " @vfu_ctx: the libvfio-user context"]
#[doc = " @buf: buffer containing the data to be written or data to be read into"]
#[doc = " @count: number of bytes being read or written"]
#[doc = " @offset: byte offset within the region"]
#[doc = " @is_write: whether or not this is a write"]
#[doc = ""]
#[doc = " @returns the number of bytes read or written, or -1 on error, setting errno."]
pub type vfu_region_access_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        vfu_ctx: *mut vfu_ctx_t,
        buf: *mut ::std::os::raw::c_char,
        count: size_t,
        offset: loff_t,
        is_write: bool,
    ) -> ssize_t,
>;
extern "C" {
    #[doc = " Set up a device region."]
    #[doc = ""]
    #[doc = " A region is an area of device memory that can be accessed by the client,"]
    #[doc = " either via VFIO_USER_REGION_READ/WRITE, or directly by mapping the region"]
    #[doc = " into the client's address space if an fd is given."]
    #[doc = ""]
    #[doc = " A mappable region can be split into mappable sub-areas according to the"]
    #[doc = " @mmap_areas array. Note that the client can memory map any part of the"]
    #[doc = " file descriptor, even if not supposed to do so according to @mmap_areas."]
    #[doc = " There is no way in Linux to avoid this."]
    #[doc = ""]
    #[doc = " TODO maybe we should introduce per-sparse region file descriptors so that"]
    #[doc = " the client cannot possibly memory map areas it's not supposed to. Even if"]
    #[doc = " the client needs to have region under the same backing file, it is possible"]
    #[doc = " to create linear device-mapper targets, one for each area, and provide file"]
    #[doc = " descriptors of these DM targets. This is something we can document and"]
    #[doc = " demonstrate in a sample."]
    #[doc = ""]
    #[doc = " Areas that are accessed via such a mapping by definition do not invoke any"]
    #[doc = " given callback.  However, the callback can still be invoked, even on a"]
    #[doc = " mappable area, if the client chooses to call VFIO_USER_REGION_READ/WRITE."]
    #[doc = ""]
    #[doc = " The following regions are special and are explained below:"]
    #[doc = "  - VFU_PCI_DEV_CFG_REGION_IDX,"]
    #[doc = "  - VFU_PCI_DEV_MIGR_REGION_IDX, and"]
    #[doc = "  - VFU_GENERIC_DEV_MIGR_REG_IDX."]
    #[doc = ""]
    #[doc = " Region VFU_PCI_DEV_CFG_REGION_IDX, corresponding to PCI config space, has"]
    #[doc = " special handling:"]
    #[doc = ""]
    #[doc = "  - the @size argument is ignored: the region size is always the size defined"]
    #[doc = "    by the relevant PCI specification"]
    #[doc = "  - all accesses to the standard PCI header (i.e. the first 64 bytes of the"]
    #[doc = "    region) are handled by the library"]
    #[doc = "  - all accesses to known PCI capabilities (see vfu_pci_add_capability())"]
    #[doc = "    are handled by the library"]
    #[doc = "  - if no callback is provided, reads to other areas are a simple memcpy(),"]
    #[doc = "    and writes are an error"]
    #[doc = "  - otherwise, the callback is expected to handle the access"]
    #[doc = ""]
    #[doc = " Regions VFU_PCI_DEV_MIGR_REGION_IDX and VFU_GENERIC_DEV_MIGR_REG_IDX,"]
    #[doc = " corresponding to the migration region, enable live migration support for"]
    #[doc = " the device. The migration region must contain at the beginning the migration"]
    #[doc = " registers (struct vfio_device_migration_info defined in <linux/vfio.h>) and"]
    #[doc = " the remaining part of the region can be arbitrarily used by the device"]
    #[doc = " implementation. The region provided must have at least"]
    #[doc = " vfu_get_migr_register_area_size() bytes available at the start of the region"]
    #[doc = " (this size is guaranteed to be page-aligned). If mmap_areas is given, it"]
    #[doc = " must _not_ include this part of the region."]
    #[doc = ""]
    #[doc = " libvfio-user offers two ways for the migration region to be used:"]
    #[doc = "  1. natively: the device implementation must handle accesses to the"]
    #[doc = "      migration registers and migration data via the region callbacks. The"]
    #[doc = "      semantics of these registers are explained in <linux/vfio.h>."]
    #[doc = "  2. via the vfu_migration_t callbacks: the device implementation registers"]
    #[doc = "      a set of callbacks by calling vfu_setup_device_migration. The region's"]
    #[doc = "      read/write callbacks are never called."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @region_idx: region index"]
    #[doc = " @size: size of the region"]
    #[doc = " @region_access: callback function to access region"]
    #[doc = " @flags: region flags (VFU_REGION_FLAG_*)"]
    #[doc = " @mmap_areas: array of memory mappable areas; if an fd is provided, but this"]
    #[doc = " is NULL, then the entire region is mappable."]
    #[doc = " @nr_mmap_areas: number of sparse areas in @mmap_areas; must be provided if"]
    #[doc = "  the @mmap_areas is non-NULL, or 0 otherwise."]
    #[doc = " @fd: file descriptor of the file backing the region if the region is"]
    #[doc = "  mappable; it is the server's responsibility to create a file suitable for"]
    #[doc = "  memory mapping by the client."]
    #[doc = ""]
    #[doc = " @returns 0 on success, -1 on error, Sets errno."]
    pub fn vfu_setup_region(
        vfu_ctx: *mut vfu_ctx_t,
        region_idx: ::std::os::raw::c_int,
        size: size_t,
        region_access: vfu_region_access_cb_t,
        flags: ::std::os::raw::c_int,
        mmap_areas: *mut iovec,
        nr_mmap_areas: u32,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfu_get_migr_register_area_size() -> size_t;
}
pub const vfu_reset_type_VFU_RESET_DEVICE: vfu_reset_type = 0;
pub const vfu_reset_type_VFU_RESET_LOST_CONN: vfu_reset_type = 1;
pub type vfu_reset_type = ::std::os::raw::c_uint;
pub use self::vfu_reset_type as vfu_reset_type_t;
pub type vfu_reset_cb_t = ::std::option::Option<
    unsafe extern "C" fn(vfu_ctx: *mut vfu_ctx_t, type_: vfu_reset_type_t) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Set up device reset callback."]
    #[doc = ""]
    #[doc = " A reset should ensure that all on-going use of device IRQs or guest memory is"]
    #[doc = " completed or cancelled before returning from the callback."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @reset: device reset callback"]
    pub fn vfu_setup_device_reset_cb(
        vfu_ctx: *mut vfu_ctx_t,
        reset: vfu_reset_cb_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_dma_info {
    pub iova: iovec,
    pub vaddr: *mut ::std::os::raw::c_void,
    pub mapping: iovec,
    pub page_size: size_t,
    pub prot: u32,
}
#[test]
fn bindgen_test_layout_vfu_dma_info() {
    assert_eq!(
        ::std::mem::size_of::<vfu_dma_info>(),
        56usize,
        concat!("Size of: ", stringify!(vfu_dma_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_dma_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vfu_dma_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_dma_info>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_dma_info),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_dma_info>())).vaddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_dma_info),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_dma_info>())).mapping as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_dma_info),
            "::",
            stringify!(mapping)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_dma_info>())).page_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_dma_info),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vfu_dma_info>())).prot as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_dma_info),
            "::",
            stringify!(prot)
        )
    );
}
pub type vfu_dma_info_t = vfu_dma_info;
pub type vfu_dma_register_cb_t =
    ::std::option::Option<unsafe extern "C" fn(vfu_ctx: *mut vfu_ctx_t, info: *mut vfu_dma_info_t)>;
pub type vfu_dma_unregister_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        vfu_ctx: *mut vfu_ctx_t,
        info: *mut vfu_dma_info_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Set up device DMA registration callbacks. When libvfio-user is notified of a"]
    #[doc = " DMA range addition or removal, these callbacks will be invoked."]
    #[doc = ""]
    #[doc = " If this function is not called, guest DMA regions are not accessible via"]
    #[doc = " vfu_addr_to_sg()."]
    #[doc = ""]
    #[doc = " To directly access this DMA memory via a local mapping with vfu_map_sg(), at"]
    #[doc = " least @dma_unregister must be provided."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @dma_register: DMA region registration callback (optional)"]
    #[doc = " @dma_unregister: DMA region unregistration callback (optional)"]
    pub fn vfu_setup_device_dma(
        vfu_ctx: *mut vfu_ctx_t,
        dma_register: vfu_dma_register_cb_t,
        dma_unregister: vfu_dma_unregister_cb_t,
    ) -> ::std::os::raw::c_int;
}
pub const vfu_dev_irq_type_VFU_DEV_INTX_IRQ: vfu_dev_irq_type = 0;
pub const vfu_dev_irq_type_VFU_DEV_MSI_IRQ: vfu_dev_irq_type = 1;
pub const vfu_dev_irq_type_VFU_DEV_MSIX_IRQ: vfu_dev_irq_type = 2;
pub const vfu_dev_irq_type_VFU_DEV_ERR_IRQ: vfu_dev_irq_type = 3;
pub const vfu_dev_irq_type_VFU_DEV_REQ_IRQ: vfu_dev_irq_type = 4;
pub const vfu_dev_irq_type_VFU_DEV_NUM_IRQS: vfu_dev_irq_type = 5;
pub type vfu_dev_irq_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Set up device IRQ counts."]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @type: IRQ type (VFU_DEV_INTX_IRQ ... VFU_DEV_REQ_IRQ)"]
    #[doc = " @count: number of irqs"]
    pub fn vfu_setup_device_nr_irqs(
        vfu_ctx: *mut vfu_ctx_t,
        type_: vfu_dev_irq_type,
        count: u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Migration callback function."]
#[doc = " @vfu_ctx: the libvfio-user context"]
pub type vfu_migration_callback_t =
    ::std::option::Option<unsafe extern "C" fn(vfu_ctx: *mut vfu_ctx_t) -> ::std::os::raw::c_int>;
pub const vfu_migr_state_t_VFU_MIGR_STATE_STOP: vfu_migr_state_t = 0;
pub const vfu_migr_state_t_VFU_MIGR_STATE_RUNNING: vfu_migr_state_t = 1;
pub const vfu_migr_state_t_VFU_MIGR_STATE_STOP_AND_COPY: vfu_migr_state_t = 2;
pub const vfu_migr_state_t_VFU_MIGR_STATE_PRE_COPY: vfu_migr_state_t = 3;
pub const vfu_migr_state_t_VFU_MIGR_STATE_RESUME: vfu_migr_state_t = 4;
pub type vfu_migr_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vfu_migration_callbacks_t {
    pub version: ::std::os::raw::c_int,
    pub transition: ::std::option::Option<
        unsafe extern "C" fn(
            vfu_ctx: *mut vfu_ctx_t,
            state: vfu_migr_state_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_pending_bytes:
        ::std::option::Option<unsafe extern "C" fn(vfu_ctx: *mut vfu_ctx_t) -> __u64>,
    pub prepare_data: ::std::option::Option<
        unsafe extern "C" fn(
            vfu_ctx: *mut vfu_ctx_t,
            offset: *mut __u64,
            size: *mut __u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub read_data: ::std::option::Option<
        unsafe extern "C" fn(
            vfu_ctx: *mut vfu_ctx_t,
            buf: *mut ::std::os::raw::c_void,
            count: __u64,
            offset: __u64,
        ) -> ssize_t,
    >,
    pub write_data: ::std::option::Option<
        unsafe extern "C" fn(
            vfu_ctx: *mut vfu_ctx_t,
            buf: *mut ::std::os::raw::c_void,
            count: __u64,
            offset: __u64,
        ) -> ssize_t,
    >,
    pub data_written: ::std::option::Option<
        unsafe extern "C" fn(vfu_ctx: *mut vfu_ctx_t, count: __u64) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_vfu_migration_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<vfu_migration_callbacks_t>(),
        56usize,
        concat!("Size of: ", stringify!(vfu_migration_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vfu_migration_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vfu_migration_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).transition as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(transition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).get_pending_bytes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(get_pending_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).prepare_data as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(prepare_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).read_data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(read_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).write_data as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(write_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vfu_migration_callbacks_t>())).data_written as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vfu_migration_callbacks_t),
            "::",
            stringify!(data_written)
        )
    );
}
extern "C" {
    #[doc = " vfu_setup_device_migration provides an abstraction over the migration"]
    #[doc = " protocol: the user specifies a set of callbacks which are called in response"]
    #[doc = " to client accesses of the migration region; the migration region read/write"]
    #[doc = " callbacks are not called after this function call. Offsets in callbacks are"]
    #[doc = " relative to @data_offset."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @callbacks: migration callbacks"]
    #[doc = " @data_offset: offset in the migration region where data begins."]
    #[doc = ""]
    #[doc = " @returns 0 on success, -1 on error, sets errno."]
    pub fn vfu_setup_device_migration_callbacks(
        vfu_ctx: *mut vfu_ctx_t,
        callbacks: *const vfu_migration_callbacks_t,
        data_offset: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Triggers an interrupt."]
    #[doc = ""]
    #[doc = " libvfio-user takes care of using the correct IRQ type (IRQ index: INTx or"]
    #[doc = " MSI/X), the caller only needs to specify the sub-index."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context to trigger interrupt"]
    #[doc = " @subindex: vector subindex to trigger interrupt on"]
    #[doc = ""]
    #[doc = " @returns 0 on success, or -1 on failure. Sets errno."]
    pub fn vfu_irq_trigger(vfu_ctx: *mut vfu_ctx_t, subindex: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes a guest physical address and returns a list of scatter/gather entries"]
    #[doc = " than can be individually mapped in the program's virtual memory.  A single"]
    #[doc = " linear guest physical address span may need to be split into multiple"]
    #[doc = " scatter/gather regions due to limitations of how memory can be mapped."]
    #[doc = ""]
    #[doc = " vfu_setup_device_dma() must have been called prior to using this function."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @dma_addr: the guest physical address"]
    #[doc = " @len: size of memory to be mapped"]
    #[doc = " @sg: array that receives the scatter/gather entries to be mapped"]
    #[doc = " @max_sg: maximum number of elements in above array"]
    #[doc = " @prot: protection as defined in <sys/mman.h>"]
    #[doc = ""]
    #[doc = " @returns the number of scatter/gather entries created on success, and on"]
    #[doc = " failure:"]
    #[doc = "  -1:         if the GPA address span is invalid (errno=ENOENT) or"]
    #[doc = "              protection violation (errno=EACCES)"]
    #[doc = "  (-x - 1):   if @max_sg is too small, where x is the number of scatter/gather"]
    #[doc = "              entries necessary to complete this request (errno=0)."]
    pub fn vfu_addr_to_sg(
        vfu_ctx: *mut vfu_ctx_t,
        dma_addr: vfu_dma_addr_t,
        len: size_t,
        sg: *mut dma_sg_t,
        max_sg: ::std::os::raw::c_int,
        prot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Maps a list scatter/gather entries from the guest's physical address space"]
    #[doc = " to the program's virtual memory. It is the caller's responsibility to remove"]
    #[doc = " the mappings by calling vfu_unmap_sg()."]
    #[doc = ""]
    #[doc = " This is only supported when a @dma_unregister callback is provided to"]
    #[doc = " vfu_setup_device_dma()."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @sg: array of scatter/gather entries returned by vfu_addr_to_sg"]
    #[doc = " @iov: array of iovec structures (defined in <sys/uio.h>) to receive each"]
    #[doc = "       mapping"]
    #[doc = " @cnt: number of scatter/gather entries to map"]
    #[doc = ""]
    #[doc = " @returns 0 on success, -1 on failure. Sets errno."]
    pub fn vfu_map_sg(
        vfu_ctx: *mut vfu_ctx_t,
        sg: *const dma_sg_t,
        iov: *mut iovec,
        cnt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unmaps a list scatter/gather entries (previously mapped by vfu_map_sg()) from"]
    #[doc = " the program's virtual memory."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @sg: array of scatter/gather entries to unmap"]
    #[doc = " @iov: array of iovec structures for each scatter/gather entry"]
    #[doc = " @cnt: number of scatter/gather entries to unmap"]
    pub fn vfu_unmap_sg(
        vfu_ctx: *mut vfu_ctx_t,
        sg: *const dma_sg_t,
        iov: *mut iovec,
        cnt: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Read from the dma region exposed by the client."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @sg: a DMA segment obtained from dma_addr_to_sg"]
    #[doc = " @data: data buffer to read into"]
    #[doc = ""]
    #[doc = " @returns 0 on success, -1 on failure. Sets errno."]
    pub fn vfu_dma_read(
        vfu_ctx: *mut vfu_ctx_t,
        sg: *mut dma_sg_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write to the dma region exposed by the client."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @sg: a DMA segment obtained from dma_addr_to_sg"]
    #[doc = " @data: data buffer to write"]
    #[doc = ""]
    #[doc = " @returns 0 on success, -1 on failure. Sets errno."]
    pub fn vfu_dma_write(
        vfu_ctx: *mut vfu_ctx_t,
        sg: *mut dma_sg_t,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub const VFU_PCI_DEV_BAR0_REGION_IDX: ::std::os::raw::c_uint = 0;
pub const VFU_PCI_DEV_BAR1_REGION_IDX: ::std::os::raw::c_uint = 1;
pub const VFU_PCI_DEV_BAR2_REGION_IDX: ::std::os::raw::c_uint = 2;
pub const VFU_PCI_DEV_BAR3_REGION_IDX: ::std::os::raw::c_uint = 3;
pub const VFU_PCI_DEV_BAR4_REGION_IDX: ::std::os::raw::c_uint = 4;
pub const VFU_PCI_DEV_BAR5_REGION_IDX: ::std::os::raw::c_uint = 5;
pub const VFU_PCI_DEV_ROM_REGION_IDX: ::std::os::raw::c_uint = 6;
pub const VFU_PCI_DEV_CFG_REGION_IDX: ::std::os::raw::c_uint = 7;
pub const VFU_PCI_DEV_VGA_REGION_IDX: ::std::os::raw::c_uint = 8;
pub const VFU_PCI_DEV_MIGR_REGION_IDX: ::std::os::raw::c_uint = 9;
pub const VFU_PCI_DEV_NUM_REGIONS: ::std::os::raw::c_uint = 10;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const vfu_pci_type_t_VFU_PCI_TYPE_CONVENTIONAL: vfu_pci_type_t = 0;
pub const vfu_pci_type_t_VFU_PCI_TYPE_PCI_X_1: vfu_pci_type_t = 1;
pub const vfu_pci_type_t_VFU_PCI_TYPE_PCI_X_2: vfu_pci_type_t = 2;
pub const vfu_pci_type_t_VFU_PCI_TYPE_EXPRESS: vfu_pci_type_t = 3;
pub type vfu_pci_type_t = ::std::os::raw::c_uint;
pub const VFU_GENERIC_DEV_MIGR_REGION_IDX: ::std::os::raw::c_uint = 0;
pub const VFU_GENERIC_DEV_NUM_REGIONS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Initialize the context for a PCI device. This function must be called only"]
    #[doc = " once per libvfio-user context."]
    #[doc = ""]
    #[doc = " This function initializes a buffer for the PCI config space, accessible via"]
    #[doc = " vfu_pci_get_config_space()."]
    #[doc = ""]
    #[doc = " Returns 0 on success, or -1 on error, setting errno."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @pci_type: PCI type (convention PCI, PCI-X mode 1, PCI-X mode2, PCI-Express)"]
    #[doc = " @hdr_type: PCI header type. Only PCI_HEADER_TYPE_NORMAL is supported."]
    #[doc = " @revision: PCI/PCI-X/PCIe revision"]
    pub fn vfu_pci_init(
        vfu_ctx: *mut vfu_ctx_t,
        pci_type: vfu_pci_type_t,
        hdr_type: ::std::os::raw::c_int,
        revision: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfu_pci_set_id(vfu_ctx: *mut vfu_ctx_t, vid: u16, did: u16, ssvid: u16, ssid: u16);
}
extern "C" {
    pub fn vfu_pci_set_class(vfu_ctx: *mut vfu_ctx_t, base: u8, sub: u8, pi: u8);
}
extern "C" {
    pub fn vfu_pci_get_config_space(vfu_ctx: *mut vfu_ctx_t) -> *mut vfu_pci_config_space_t;
}
extern "C" {
    #[doc = " Add a PCI capability to PCI config space."]
    #[doc = ""]
    #[doc = " Certain standard capabilities are handled entirely within the library:"]
    #[doc = ""]
    #[doc = " PCI_CAP_ID_EXP (pxcap)"]
    #[doc = " PCI_CAP_ID_MSIX (msixcap)"]
    #[doc = " PCI_CAP_ID_PM (pmcap)"]
    #[doc = ""]
    #[doc = " However, they must still be explicitly initialized and added here."]
    #[doc = ""]
    #[doc = " The contents of @data are copied in. It must start with either a struct"]
    #[doc = " cap_hdr or a struct ext_cap_hdr, with the ID field set; the 'next' field is"]
    #[doc = " ignored.  For PCI_CAP_ID_VNDR or PCI_EXT_CAP_ID_VNDR, the embedded size field"]
    #[doc = " must also be set; in general, any non-fixed-size capability must be"]
    #[doc = " initialized such that the size can be derived at this point."]
    #[doc = ""]
    #[doc = " If @pos is non-zero, the capability will be placed at the given offset within"]
    #[doc = " configuration space. It must not overlap the PCI standard header, or any"]
    #[doc = " existing capability. Note that if a capability is added \"out of order\" in"]
    #[doc = " terms of the offset, there is no re-ordering of the capability list written"]
    #[doc = " in configuration space."]
    #[doc = ""]
    #[doc = " If @pos is zero, the capability will be placed at a suitable offset"]
    #[doc = " automatically."]
    #[doc = ""]
    #[doc = " The @flags field can be set as follows:"]
    #[doc = ""]
    #[doc = " VFU_CAP_FLAG_EXTENDED: this is an extended capability; supported if device is"]
    #[doc = " of PCI type VFU_PCI_TYPE_{PCI_X_2,EXPRESS}."]
    #[doc = ""]
    #[doc = " VFU_CAP_FLAG_CALLBACK: all accesses to the capability are delegated to the"]
    #[doc = " callback for the region VFU_PCI_DEV_CFG_REGION_IDX. The callback should copy"]
    #[doc = " data into and out of the capability as needed (this could be directly on the"]
    #[doc = " config space area from vfu_pci_get_config_space()). It is not supported to"]
    #[doc = " allow writes to the initial capability header (ID/next fields)."]
    #[doc = ""]
    #[doc = " VFU_CAP_FLAG_READONLY: this prevents clients from writing to the capability."]
    #[doc = " By default, clients are allowed to write to any part of the capability,"]
    #[doc = " excluding the initial header."]
    #[doc = ""]
    #[doc = " Returns the offset of the capability in config space, or -1 on error, with"]
    #[doc = " errno set."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @pos: specific offset for the capability, or 0."]
    #[doc = " @flags: VFU_CAP_FLAG_*"]
    #[doc = " @data: capability data, including the header"]
    pub fn vfu_pci_add_capability(
        vfu_ctx: *mut vfu_ctx_t,
        pos: size_t,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Find the offset within config space of a given capability (if there are"]
    #[doc = " multiple possible matches, use vfu_pci_find_next_capability())."]
    #[doc = ""]
    #[doc = " Returns 0 if no such capability was found, with errno set."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @extended whether capability is an extended one or not"]
    #[doc = " @id: capability id (PCI_CAP_ID_* or PCI_EXT_CAP_ID *)"]
    pub fn vfu_pci_find_capability(
        vfu_ctx: *mut vfu_ctx_t,
        extended: bool,
        cap_id: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " Find the offset within config space of the given capability, starting from"]
    #[doc = " @pos, which must be the valid offset of an existing capability. This can be"]
    #[doc = " used to iterate through multiple capabilities with the same ID."]
    #[doc = ""]
    #[doc = " Returns 0 if no more matching capabilities were found, with errno set."]
    #[doc = ""]
    #[doc = " @vfu_ctx: the libvfio-user context"]
    #[doc = " @extended whether capability is an extended one or not"]
    #[doc = " @pos: offset within config space to start looking"]
    #[doc = " @id: capability id (PCI_CAP_ID_*)"]
    pub fn vfu_pci_find_next_capability(
        vfu_ctx: *mut vfu_ctx_t,
        extended: bool,
        pos: size_t,
        cap_id: ::std::os::raw::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " Returns the memory offset where the specific region starts in device memory."]
    #[doc = ""]
    #[doc = " @region: the region to translate"]
    #[doc = ""]
    #[doc = " @returns the absolute offset"]
    pub fn vfu_region_to_offset(region: u32) -> u64;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
