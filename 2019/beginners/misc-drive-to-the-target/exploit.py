#!/usr/bin/env python3
#
# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.import requests

import requests
import pyproj
import time
import math
from geopy.distance import geodesic
from datetime import datetime, timedelta
import re

HOST = 'https://drivetothetarget-19a22ab12qofd-dot-upheld-fold-240117.appspot.com'
REQUEST_SLEEP = 1

def get_start_point():
    res = requests.get(HOST).text      
    lat = re.search('name="lat" value="(.+?)"', res).group(1)
    lon = re.search('name="lon" value="(.+?)"', res).group(1)
    token = re.search('name="token" value="(.+?)"', res).group(1)
    return (float(lat), float(lon), token)

def request(lat, lon, token):
    res = requests.get('%s?lat=%.8f&lon=%.8f&token=%s' % (HOST, lat, lon, token))
    return re.search('<p>(.+?)</p>', res.text).group(1), re.search('token" value="(.+?)">', res.text).group(1)

proj = pyproj.Proj("+proj=gnom +lat_0=51.0 +lon_0=0")

def go(p, r, angle, force_answer=False):
    # proj expects lon-lat and x-y order
    x0, y0 = proj(p[1], p[0])
    x1 = x0 + r * math.cos(angle)
    y1 = y0 + r * math.sin(angle)
    lon, lat = proj(x1, y1, inverse=True)

    msg, token = request(lat, lon, p[2])
    verdict = 'TOO_FAST'
    if 'CTF' in msg:
      print(msg)
      sys.exit(0)
    if 'further' in msg:
        verdict = 'FURTHER'
    elif 'closer' in msg:
        verdict = 'CLOSER'
    elif force_answer:
        return go(p, r, angle, True)
    return (lat, lon, token), verdict

def find_max_speed(p0):
    mul = 10
    def too_fast(speed):
        p, _ = go(p0, 0, 0)
        time.sleep(REQUEST_SLEEP / mul)
        _, verdict = go(p, speed, 0)
        return verdict == 'TOO_FAST'
    min_speed, max_speed = 0, 1000 * 1609 / 3600 * REQUEST_SLEEP
    for _ in range(30):
        speed = (min_speed + max_speed) / 2
        if too_fast(speed):
            max_speed = speed
        else:
            min_speed = speed
    return  min_speed * mul
 
def find_direction(p0, r):
    closer_dir, further_dir = (0, math.pi) if go(p0, r, 0, True)[1] == 'CLOSER' else (math.pi, 2 * math.pi)
    for _ in range(30):
        mid = (closer_dir + further_dir) / 2
        _, verdict = go(p0, r, mid, True)
        if verdict == 'CLOSER':
            closer_dir = mid
        else:
            further_dir = mid
        time.sleep(REQUEST_SLEEP / 10)
    return closer_dir - math.pi / 2
 
p0 = get_start_point()
# Final point is not know but specify it if you want to see how the distance decreases
final_point = (51.4921, -0.1929)
r = find_max_speed(p0) * 0.7
print('max speed', r / REQUEST_SLEEP * 3600 / 1609)
dir = 0
p = p0
step = 0
pos_time = datetime.now()
start_time = pos_time
start_point = p[:2]

while True:
    if step % 1000 == 0:
        old_dir = dir
        dir = find_direction(p, r / 10)
        print('changed direction from %f to %f' % (old_dir, dir))
    p1, verdict = go(p, r, dir)
    if verdict == 'CLOSER':
        step += 1
        cur_time = datetime.now()

        if final_point:
            def speed(target, p0, p1, t0, t1):
                distance = geodesic(target, p0[:2]) - geodesic(target, p1[:2])
                time_hours = (t1 - t0) / timedelta(hours=1)
                return distance.miles / time_hours
            average_speed = speed(final_point, start_point, p1, start_time, cur_time)
            step_speed = speed(final_point, p, p1, pos_time, cur_time)
            print('avg=%.0fmph cur=%.0fmph' % (average_speed, step_speed),)
        
        pos_time = cur_time
        p = p1
        print('%.4f %.4f' % (p[0], p[1]))
    elif verdict == 'FURTHER':
        r *= 0.9
        step = 0 # to recalculate direction on the next iteration
        print('reduced speed', r)
    else:
        print('TOOFAST')
    time.sleep(REQUEST_SLEEP)
