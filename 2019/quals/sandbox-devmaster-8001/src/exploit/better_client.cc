// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Author: Ian Eldred Pudney

#include "../client_lib.h"

string usage = "Usage: client <server-subprocess> [<server-subprocess args>...] -- [<files>...] -- [<results>...] -- <command> <args>...";

int main(int argc, char** argv) {
  int i = 1;

  std::vector<string> server_args;
  for(;;++i) {
    if (i == argc) {
      std::cerr << usage << std::endl;
      exit(-1);
    }
    if (argv[i] == string("--")) break;
    server_args.push_back(argv[i]);
  }
  ++i;

  std::vector<std::pair<string, string>> files;
  for(;;++i) {
    if (i == argc) {
      std::cerr << usage << std::endl;
      exit(-1);
    }
    if (argv[i] == string("--")) break;

    files.push_back({argv[i], ReadFile(argv[i])});
  }
  ++i;

  std::vector<string> results;
  for(;;++i) {
    if (i == argc) {
      std::cerr << usage << std::endl;
      exit(-1);
    }
    if (argv[i] == string("--")) break;
    results.push_back(argv[i]);
  }
  ++i;

  std::vector<string> args;
  for (;i < argc; ++i) {
    args.push_back(argv[i]);
  }

  sp::Popen proc(server_args, sp::shell{true}, sp::input{sp::PIPE}, sp::output{sp::PIPE}/*, sp::error{sp::PIPE}*/);

  bool process_done = true;
  mutex lock;
  condition_variable cv;
  int ref_id = 0;
  int remaining_results = results.size();
  string escape_command;

  std::thread stdin_loop([&]() {
    while(true) {
      string s;
      getline(cin, s);
      if (!cin) break;

      lock.lock();
      if (process_done) {
        escape_command = s;
        std::cerr << "Set escape_command to '" << escape_command << "'" << std::endl;
        cv.notify_one();
        lock.unlock();
        continue;
      }
      lock.unlock();

      SendStdin(proc, ref_id, s + "\n");
    }
    proc.close_input();
  });

  std::thread recv_loop([&]() {
    int exit_code;
    while(true) {
      int opcode = ReadIntDirectly(proc);
      if (!ops.count(opcode)) {
        std::cerr << "Got unexpected opcode " << opcode << " " << std::hex << opcode << std::dec << " (";
        char* opcode_ptr = (char*)&opcode;
        for (int i = 0; i < 4; ++i) {
          std::cerr << *(opcode_ptr+i);
        }
        std::cerr << ") from server." << std::endl;
        continue;
      }

      stringstream message;
      message << ReadStringDirectly(proc);

      if (opcode == 5 /*exited*/) {
        exit_code = Exited(message);

        if (exit_code != 0 || results.empty() || remaining_results == 0) {
          lock.lock();
          process_done = true;
          cv.notify_one();
          lock.unlock();
        }

        for (const string& result : results) {
          std::cerr << "[Client] Sending fetch " << result << std::endl;
          SendFetch(proc, ref_id, result);
        }
        continue;
      }

      ops[opcode](message);

      if (opcode == 8 /*fetched*/) {
        remaining_results--;
        if (remaining_results == 0) {
          lock.lock();
          process_done = true;
          cv.notify_one();
          lock.unlock();
        }
      }
    }

    proc.close_output();
  });

  while (true) {
    std::cout << "Enter either 'b' or 'a':" << std::endl;
    char cmd;
    {
      std::unique_lock<mutex> locker(lock);
      escape_command = "";
      while (escape_command == "") {
        cv.wait(locker);
      }
      cmd = escape_command[0];
    }
    std::cerr << "Read: " << cmd << std::endl;
    if (cmd != 'b' && cmd != 'a') continue;

    {
      std::unique_lock<mutex> locker(lock);
      process_done = false;
    }

    if (cmd == 'b') {
      SendBuild(proc, ref_id, args, files);
    } else {
      remaining_results = 0;
      SendAdmin(proc, ref_id);
    }
    std::unique_lock<mutex> locker2(lock);
    while (!process_done) {
      cv.wait(locker2);
    }
    ++ref_id;
    remaining_results = results.size();
  }

  stdin_loop.join();
  recv_loop.join();
  return proc.wait();
}
