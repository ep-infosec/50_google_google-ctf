#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import binascii
import requests
import struct
import sys

HUB_ENDPOINT = 'http://127.0.0.1:8080/SendIRCommand'

CMD_PING = 0x01

CMD_GETTEMP = 0x10
CMD_GETHUMIDITY = 0x11
CMD_GETCO2 = 0x12
CMD_GETSMOKEDETECTOR = 0x13

CMD_SETTIME = 0x20

CMD_SYSVER = 0x30

CMD_REPLY = 0x80

def crc8(data):
    # Expect a list of integer
    # LFSR calculation of CRC8-CCITT
    crc = 0
    for v in data:
        crc = crc ^ (v << 8)
        for i in range(8):
            if (crc & 0x8000):
                crc = crc ^ (0x1070 << 3)
            crc = crc << 1
    return (crc >> 8)

def send_command(command, arguments, expected_reply_len = None):
    if len(arguments) > 251:
        print('Argument too long.')
        sys.exit(1)

    packet = [0x55,len(arguments)+4,command,] + list(arguments)
    checksum = crc8(packet)
    packet = packet + [checksum,]
    packet = bytes(packet)
    packet_hex = binascii.hexlify(packet)

    # Send the request packet to the Hub to be transmitted to the smart clock through 940nm IR at 1786bps
    req = requests.post(HUB_ENDPOINT, data = packet_hex)
    if req.status_code != requests.codes.ok:
        print('Hub returned error')
        sys.exit(1)
    try:
        reply = binascii.unhexlify(req.text)
    except:
        print( 'The Flag: "%s"'%req.text )
        sys.exit(0)

    if len(reply) == 0:
        # It's offline
        print('Smart Clock is unreachable.')
        sys.exit(0)
    if len(reply)-1 != expected_reply_len and expected_reply_len is not None:
        print('Smart Clock returned an invalid response.')
        sys.exit(0)

    # Verify that the reply command is correct
    if reply[0] != command | CMD_REPLY:
        print('Invalid reply received')
        sys.exit(1)

    return reply[1:]

def main():
    cmd = [0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0,
    1, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0,
    1, 0, 0, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1, 0,
    1,
    0, 0, 0, 0, 0, 0
    ]

    while len(cmd)%8 != 0:
        cmd += [0,]

    payload = []
    for i in range(len(cmd)//8):
        cbyte = 0
        shift = 1
        for j in range(8):
            if cmd[i*8+j]:
                cbyte = cbyte | shift
            shift = shift << 1
        payload.append(cbyte)
    payload = bytes(payload)

    reply = send_command(CMD_PING, payload, len(payload))

if __name__ == '__main__':
    main()
